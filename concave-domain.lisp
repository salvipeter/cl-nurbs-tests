(in-package :cl-nurbs-tests)

(defun concavep (points i)
  "Assumes that POINTS is given in positive order, i.e. `matter' is on the left side."
  (let* ((n (length points))
         (im (mod (1- i) n))
         (ip (mod (1+ i) n))
         (u (vnormalize (v- (elt points ip) (elt points i))))
         (v (vnormalize (v- (elt points im) (elt points i)))))
    (>= (- (* (elt u 0) (elt v 1))
           (* (elt u 1) (elt v 0)))
       0)))

(defun snip-triangle (points i)
  (append (subseq points 0 i)
          (subseq points (1+ i))))

(defun mesh-triangle (points i)
  (let* ((n (length points))
         (a (elt points (mod (1- i) n)))
         (b (elt points i))
         (c (elt points (mod (1+ i) n))))
    (iter (for i from 1 to *resolution*)
          (for u = (/ i *resolution*))
          (for p = (affine-combine b u a))
          (for q = (affine-combine b u c))
          (for last-row first (list (list b)) then (nreverse row))
          (for row = '())
          (appending
           (iter (for j from 0 below i)
                 (for tri = (list (affine-combine p (/ j i) q)
                                  (affine-combine p (/ (1+ j) i) q)
                                  (if (= j 0)
                                      (elt (elt last-row j) 0)
                                      (elt (elt last-row (1- j)) 1))))
                 (push tri row)
                 (collect tri)
                 (unless (= j 0)
                   (collect (list (affine-combine p (/ j i) q)
                                  (elt (elt last-row (1- j)) 1)
                                  (elt (elt last-row (1- j)) 0)))))))))

(defun mesh-concave (points)
  (iter (with points = (copy-list points))
        (while (>= (length points) 3))
        (for i = (or (iter (with n = (length points))
                           (for j from 0 below n)
                           (when (and (not (concavep points j))
                                      (or (concavep points (mod (1- j) n))
                                          (concavep points (mod (1+ j) n))))
                             (return j)))
                     0))
        (appending (mesh-triangle points i))
        (setf points (snip-triangle points i))))

#+nil
(labels ((to3d-pt (p) (append p '(0)))
         (to3d-tri (tri) (mapcar #'to3d-pt tri))
         (to3d (tris) (mapcar #'to3d-tri tris)))
  (let ((*resolution* 20)
        (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3))))
    (write-stl (to3d (mesh-concave points)) "/tmp/proba.stl" :ascii t)))

(defun eval-on-concave-domain (points fn)
  (let ((mesh (mesh-concave points)))
    (mapcar (lambda (tri)
              (mapcar (lambda (p)
                        (cons (funcall fn p) p))
                      tri))
            mesh)))

#+nil
(let ((*resolution* 20)
        (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3))))
  (flet ((fn (p)
           (mean-value points (cons 1 (make-list (1- (length points)) :initial-element 0)) p)))
    (write-stl (eval-on-concave-domain points #'fn) "/tmp/proba.stl" :ascii t)))
