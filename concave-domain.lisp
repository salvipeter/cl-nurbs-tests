(in-package :cl-nurbs-tests)

(defun concavep (points i)
  "Assumes that POINTS is given in positive order, i.e. `matter' is on the left side."
  (let* ((n (length points))
         (im (mod (1- i) n))
         (ip (mod (1+ i) n))
         (u (vnormalize (v- (elt points ip) (elt points i))))
         (v (vnormalize (v- (elt points im) (elt points i)))))
    (>= (- (* (elt u 0) (elt v 1))
           (* (elt u 1) (elt v 0)))
       0)))

(defun snip-triangle (points i)
  (append (subseq points 0 i)
          (subseq points (1+ i))))

(defun mesh-triangle (points i)
  (let* ((n (length points))
         (a (elt points (mod (1- i) n)))
         (b (elt points i))
         (c (elt points (mod (1+ i) n))))
    (iter (for i from 1 to *resolution*)
          (for u = (/ i *resolution*))
          (for p = (affine-combine b u a))
          (for q = (affine-combine b u c))
          (for last-row first (list (list b)) then (nreverse row))
          (for row = '())
          (appending
           (iter (for j from 0 below i)
                 (for tri = (list (affine-combine p (/ j i) q)
                                  (affine-combine p (/ (1+ j) i) q)
                                  (if (= j 0)
                                      (elt (elt last-row j) 0)
                                      (elt (elt last-row (1- j)) 1))))
                 (push tri row)
                 (collect tri)
                 (unless (= j 0)
                   (collect (list (affine-combine p (/ j i) q)
                                  (elt (elt last-row (1- j)) 1)
                                  (elt (elt last-row (1- j)) 0)))))))))

(defun segment-segment-intersection (a b)
  "Returns NIL if there is no intersection point."
  (destructuring-bind (q1 q2) a
    (let* ((p (first b))
           (v (v- (second b) (first b)))
           (i (if (> (abs (first v)) (abs (second v))) 0 1)))
      (macrolet ((x (var) `(elt ,var i))
                 (y (var) `(elt ,var (- 1 i))))
        (let ((denom (- (* (x v) (- (y q2) (y q1)))
                        (* (y v) (- (x q2) (x q1))))))
          (unless (< (abs denom) *epsilon*)
            (let ((u (/ (+ (* (x v) (- (y p) (y q1)))
                           (* (y v) (- (x q1) (x p))))
                        denom)))
              (unless (or (< u (- *epsilon*)) (> u (1+ *epsilon*)))
                (let* ((u1 (min (max u 0) 1))
                       (u2 (/ (+ (- (x q1) (x p))
                                 (* (- (x q2) (x q1)) u1))
                              (x v))))
                  (unless (or (< u2 (- *epsilon*)) (> u2 (1+ *epsilon*)))
                    (v+ q1 (v* (v- q2 q1) u1))))))))))))

(defun snippablep (points i)
  "Returns T if the segment from i-1 to i+1 does not intersect the polygon"
  (let* ((n (length points))
         (i-1 (mod (1- i) n))
         (i+1 (mod (1+ i) n)))
    (iter (for j from 0 below n)
          (for j+1 = (mod (1+ j) n))
          (when (and (/= j (mod (- i 2) n)) (/= j i-1) (/= j i) (/= j i+1)
                     (segment-segment-intersection
                      (list (elt points i-1) (elt points i+1))
                      (list (elt points j) (elt points j+1))))
            (return-from snippablep nil))))
  t)

(defun mesh-concave (points)
  (iter (with points = (copy-list points))
        (while (>= (length points) 3))
        (for i = (or (iter (with n = (length points))
                           (for j from 0 below n)
                           (when (and (not (concavep points j))
                                      (or (concavep points (mod (1- j) n))
                                          (concavep points (mod (1+ j) n)))
                                      (snippablep points j))
                             (return j)))
                     (iter (with n = (length points))
                           (for j from 0 below n)
                           (when (snippablep points j)
                             (return j)))))
        (appending (mesh-triangle points i))
        (setf points (snip-triangle points i))))

#+nil
(labels ((to3d-pt (p) (append p '(0)))
         (to3d-tri (tri) (mapcar #'to3d-pt tri))
         (to3d (tris) (mapcar #'to3d-tri tris)))
  (let ((*resolution* 20)
        (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3))))
    (write-stl (to3d (mesh-concave points)) "/tmp/proba.stl" :ascii t)))

(defun eval-on-concave-domain (points fn)
  (let ((mesh (mesh-concave points)))
    (mapcar (lambda (tri)
              (mapcar (lambda (p)
                        (cons (funcall fn p) p))
                      tri))
            mesh)))

(defun eval3d-on-concave-domain (points fn)
  (let ((mesh (mesh-concave points)))
    (mapcar (lambda (tri) (mapcar fn tri)) mesh)))

#+nil
(let ((*resolution* 20)
        (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3))))
  (flet ((fn (p)
           (mean-value points (cons 1 (make-list (1- (length points)) :initial-element 0)) p)))
    (write-stl (eval-on-concave-domain points #'fn) "/tmp/proba.stl" :ascii t)))

(defun mean-value-coordinates (points p)
  (let* ((vectors (mapcar (lambda (x) (v- p x)) points))
         (lengths (mapcar #'vlength vectors))
         (n (length points)))
    (labels ((inc (i) (mod (1+ i) n))
             (dec (i) (mod (1- i) n))
             (area (i)                  ; signed area = det(si,si+1)/2
               (let ((si (elt vectors i))
                     (si+1 (elt vectors (inc i))))
                 (/ (- (* (elt si 0) (elt si+1 1))
                       (* (elt si 1) (elt si+1 0)))
                    2.0d0))))
      (let* ((w (iter (for i from 0 below n)
                      (for Ai = (area i))
                      (for Ai-1 = (area (dec i)))
                      (for Di = (scalar-product (elt vectors (inc i)) (elt vectors i)))
                      (for Di-1 = (scalar-product (elt vectors i) (elt vectors (dec i))))
                      (for ri-1 = (elt lengths (dec i)))
                      (for ri = (elt lengths i))
                      (for ri+1 = (elt lengths (inc i)))
                      (when (< (abs ri) *epsilon*)
                        (let ((result (make-list n :initial-element 0)))
                          (setf (elt result i) 1)
                          (return-from mean-value-coordinates result)))
                      (when (and (< (abs Ai) *epsilon*)
                                 (< Di (- *epsilon*)))
                        (let ((result (make-list n :initial-element 0)))
                          (setf (elt result i) (/ ri+1 (+ ri ri+1))
                                (elt result (inc i)) (/ ri (+ ri ri+1)))
                          (return-from mean-value-coordinates result)))
                      (collect (+ (if (> (abs Ai-1) *epsilon*)
                                      (/ (- ri-1 (/ Di-1 ri)) Ai-1)
                                      0)
                                  (if (> (abs Ai) *epsilon*)
                                      (/ (- ri+1 (/ Di ri)) Ai)
                                      0)))))
             (wsum (reduce #'+ w)))
        (mapcar (lambda (wi) (/ wi wsum)) w)))))

(defun mean-kato (points i)
  (lambda (p)
    (let* ((l (mean-value-coordinates points p))
           (d (iter (with n = (length l))
                    (for i from 0 below n)
                    (for i-1 = (mod (1- i) n))
                    (collect (- 1 (elt l i-1) (elt l i))))))
      (assert (every (lambda (x) (>= x -1.0d-6)) d))
      (ribbon-blend d i))))

(defun mean-sweep (points i)
  (lambda (p)
    (let* ((n (length points))
           (i-1 (mod (1- i) n))
           (i+1 (mod (1+ i) n))
           (l (mean-value-coordinates points p))
           (d (iter (for i from 0 below n)
                    (for i-1 = (mod (1- i) n))
                    (collect (- 1 (elt l i-1) (elt l i))))))
      (safe-/ (elt d i-1) (+ (elt d i-1) (elt d i+1))))))

(defun mean-bernstein (points i j k)
  "Bivariate cubic Bernstein function B^3_j * B^3_k using the above parameters."
  (lambda (p)
    (let* ((n (length points))
           (i-1 (mod (1- i) n))
           (i+1 (mod (1+ i) n))
           (l (mean-value-coordinates points p))
           (d (iter (for i from 0 below n)
                    (for i-1 = (mod (1- i) n))
                    (collect (- 1 (elt l i-1) (elt l i)))))
           (si (safe-/ (elt d i-1) (+ (elt d i-1) (elt d i+1))))
           (di (elt d i)))
      (* (bernstein 3 j si) (bernstein 3 k di)))))

#+nil
(let ((*resolution* 50)
      ;; (points '((0 0) (0 7) (1 7) (1 4) (2 4) (2 7) (3 7) (3 4) (4 4) (4 7) (5 7)
      ;;           (5 0) (4 0) (4 3) (3 3) (3 0) (2 0) (2 3) (1 3) (1 0)))
      ;; (points '((0 0) (0 7) (1 7) (1 4) (2 4) (2 7) (3 7) (3 0) (2 0) (2 3) (1 3) (1 0)))
      ;; (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3)))
      (points '((1 2) (1 1) (2 1) (2 0) (0 0) (0 2)))
      )
  (dotimes (j 4)
    (dotimes (k 2)
      (write-stl (eval-on-concave-domain points (mean-bernstein points 1 j k))
                 (format nil "/tmp/b~a~a.stl" j k) :ascii t))))

;;; Maxima computation:
;;; B(n,k,u) := binomial(n,k)*u^k*(1-u)^(n-k);
;;; surf : sum(sum(C(i,j,coord)*B(3,i,s)*B(1,j,d),j,0,1),i,0,3)$
;;; eq : [at(surf, coord=x) = u, at(surf, coord=y) = v]$
;;; eq_s : expand(eliminate(eq, [d]))$
;;; for i:0 thru 6 do (z: coeff(eq_s, s, i), display(i,string(z)))$
;;; for i:0 thru 3 do (z: coeff(expand(at(surf, coord=x) = u), d, i), display(i,string(z)))$
;;; (lisp-szeru iras: save("filename", expr)$

(defun reverse-cubic-parameters (cpts p)
  "CPTS is ((B00 B10 B20 B30) (B01 B11 B21 B31)).
Returns parameters for which the Bezier patch given by CPTS evaluates to P."
  (macrolet ((c (i j coord)
               (if (eq coord 'x)
                   `(first (elt (elt cpts ,j) ,i))
                   `(second (elt (elt cpts ,j) ,i)))))
    (let* ((u (first p))
           (v (second p))
           (p0 (+ (* (- (c 0 1 x)) v) (* (c 0 0 x) v) (* (c 0 1 y) u) (* (- (c 0 0 y)) u) (* (- (c 0 0 x)) (c 0 1 y)) (* (c 0 0 y) (c 0 1 x))))
           (p1 (+ (* (- 3) (c 1 1 x) v) (* 3 (c 1 0 x) v) (* 3 (c 0 1 x) v) (* (- 3) (c 0 0 x) v) (* 3 (c 1 1 y) u) (* (- 3) (c 1 0 y) u) (* (- 3) (c 0 1 y) u) (* 3 (c 0 0 y) u) (* (- 3) (c 0 0 x) (c 1 1 y)) (* 3 (c 0 0 y) (c 1 1 x)) (* 3 (c 0 1 x) (c 1 0 y)) (* (- 3) (c 0 1 y) (c 1 0 x)) (* 6 (c 0 0 x) (c 0 1 y)) (* (- 6) (c 0 0 y) (c 0 1 x))))
           (p2 (+ (* (- 3) (c 2 1 x) v) (* 3 (c 2 0 x) v) (* 6 (c 1 1 x) v) (* (- 6) (c 1 0 x) v) (* (- 3) (c 0 1 x) v) (* 3 (c 0 0 x) v) (* 3 (c 2 1 y) u) (* (- 3) (c 2 0 y) u) (* (- 6) (c 1 1 y) u) (* 6 (c 1 0 y) u) (* 3 (c 0 1 y) u) (* (- 3) (c 0 0 y) u) (* (- 3) (c 0 0 x) (c 2 1 y)) (* 3 (c 0 0 y) (c 2 1 x)) (* 3 (c 0 1 x) (c 2 0 y)) (* (- 3) (c 0 1 y) (c 2 0 x)) (* (- 9) (c 1 0 x) (c 1 1 y)) (* 15 (c 0 0 x) (c 1 1 y)) (* 9 (c 1 0 y) (c 1 1 x)) (* (- 15) (c 0 0 y) (c 1 1 x)) (* (- 15) (c 0 1 x) (c 1 0 y)) (* 15 (c 0 1 y) (c 1 0 x)) (* (- 15) (c 0 0 x) (c 0 1 y)) (* 15 (c 0 0 y) (c 0 1 x))))
           (p3 (+ (* (- (c 3 1 x)) v) (* (c 3 0 x) v) (* 3 (c 2 1 x) v) (* (- 3) (c 2 0 x) v) (* (- 3) (c 1 1 x) v) (* 3 (c 1 0 x) v) (* (c 0 1 x) v) (* (- (c 0 0 x)) v) (* (c 3 1 y) u) (* (- (c 3 0 y)) u) (* (- 3) (c 2 1 y) u) (* 3 (c 2 0 y) u) (* 3 (c 1 1 y) u) (* (- 3) (c 1 0 y) u) (* (- (c 0 1 y)) u) (* (c 0 0 y) u) (* (- (c 0 0 x)) (c 3 1 y)) (* (c 0 0 y) (c 3 1 x)) (* (c 0 1 x) (c 3 0 y)) (* (- (c 0 1 y)) (c 3 0 x)) (* (- 9) (c 1 0 x) (c 2 1 y)) (* 12 (c 0 0 x) (c 2 1 y)) (* 9 (c 1 0 y) (c 2 1 x)) (* (- 12) (c 0 0 y) (c 2 1 x)) (* 9 (c 1 1 x) (c 2 0 y)) (* (- 12) (c 0 1 x) (c 2 0 y)) (* (- 9) (c 1 1 y) (c 2 0 x)) (* 12 (c 0 1 y) (c 2 0 x)) (* 36 (c 1 0 x) (c 1 1 y)) (* (- 30) (c 0 0 x) (c 1 1 y)) (* (- 36) (c 1 0 y) (c 1 1 x)) (* 30 (c 0 0 y) (c 1 1 x)) (* 30 (c 0 1 x) (c 1 0 y)) (* (- 30) (c 0 1 y) (c 1 0 x)) (* 20 (c 0 0 x) (c 0 1 y)) (* (- 20) (c 0 0 y) (c 0 1 x))))
           (p4 (+ (* (- 3) (c 1 0 x) (c 3 1 y)) (* 3 (c 0 0 x) (c 3 1 y)) (* 3 (c 1 0 y) (c 3 1 x)) (* (- 3) (c 0 0 y) (c 3 1 x)) (* 3 (c 1 1 x) (c 3 0 y)) (* (- 3) (c 0 1 x) (c 3 0 y)) (* (- 3) (c 1 1 y) (c 3 0 x)) (* 3 (c 0 1 y) (c 3 0 x)) (* (- 9) (c 2 0 x) (c 2 1 y)) (* 27 (c 1 0 x) (c 2 1 y)) (* (- 18) (c 0 0 x) (c 2 1 y)) (* 9 (c 2 0 y) (c 2 1 x)) (* (- 27) (c 1 0 y) (c 2 1 x)) (* 18 (c 0 0 y) (c 2 1 x)) (* (- 27) (c 1 1 x) (c 2 0 y)) (* 18 (c 0 1 x) (c 2 0 y)) (* 27 (c 1 1 y) (c 2 0 x)) (* (- 18) (c 0 1 y) (c 2 0 x)) (* (- 54) (c 1 0 x) (c 1 1 y)) (* 30 (c 0 0 x) (c 1 1 y)) (* 54 (c 1 0 y) (c 1 1 x)) (* (- 30) (c 0 0 y) (c 1 1 x)) (* (- 30) (c 0 1 x) (c 1 0 y)) (* 30 (c 0 1 y) (c 1 0 x)) (* (- 15) (c 0 0 x) (c 0 1 y)) (* 15 (c 0 0 y) (c 0 1 x))))
           (p5 (+ (* (- 3) (c 2 0 x) (c 3 1 y)) (* 6 (c 1 0 x) (c 3 1 y)) (* (- 3) (c 0 0 x) (c 3 1 y)) (* 3 (c 2 0 y) (c 3 1 x)) (* (- 6) (c 1 0 y) (c 3 1 x)) (* 3 (c 0 0 y) (c 3 1 x)) (* 3 (c 2 1 x) (c 3 0 y)) (* (- 6) (c 1 1 x) (c 3 0 y)) (* 3 (c 0 1 x) (c 3 0 y)) (* (- 3) (c 2 1 y) (c 3 0 x)) (* 6 (c 1 1 y) (c 3 0 x)) (* (- 3) (c 0 1 y) (c 3 0 x)) (* 18 (c 2 0 x) (c 2 1 y)) (* (- 27) (c 1 0 x) (c 2 1 y)) (* 12 (c 0 0 x) (c 2 1 y)) (* (- 18) (c 2 0 y) (c 2 1 x)) (* 27 (c 1 0 y) (c 2 1 x)) (* (- 12) (c 0 0 y) (c 2 1 x)) (* 27 (c 1 1 x) (c 2 0 y)) (* (- 12) (c 0 1 x) (c 2 0 y)) (* (- 27) (c 1 1 y) (c 2 0 x)) (* 12 (c 0 1 y) (c 2 0 x)) (* 36 (c 1 0 x) (c 1 1 y)) (* (- 15) (c 0 0 x) (c 1 1 y)) (* (- 36) (c 1 0 y) (c 1 1 x)) (* 15 (c 0 0 y) (c 1 1 x)) (* 15 (c 0 1 x) (c 1 0 y)) (* (- 15) (c 0 1 y) (c 1 0 x)) (* 6 (c 0 0 x) (c 0 1 y)) (* (- 6) (c 0 0 y) (c 0 1 x))))
           (p6 (+ (* (- (c 3 0 x)) (c 3 1 y)) (* 3 (c 2 0 x) (c 3 1 y)) (* (- 3) (c 1 0 x) (c 3 1 y)) (* (c 0 0 x) (c 3 1 y)) (* (c 3 0 y) (c 3 1 x)) (* (- 3) (c 2 0 y) (c 3 1 x)) (* 3 (c 1 0 y) (c 3 1 x)) (* (- (c 0 0 y)) (c 3 1 x)) (* (- 3) (c 2 1 x) (c 3 0 y)) (* 3 (c 1 1 x) (c 3 0 y)) (* (- (c 0 1 x)) (c 3 0 y)) (* 3 (c 2 1 y) (c 3 0 x)) (* (- 3) (c 1 1 y) (c 3 0 x)) (* (c 0 1 y) (c 3 0 x)) (* (- 9) (c 2 0 x) (c 2 1 y)) (* 9 (c 1 0 x) (c 2 1 y)) (* (- 3) (c 0 0 x) (c 2 1 y)) (* 9 (c 2 0 y) (c 2 1 x)) (* (- 9) (c 1 0 y) (c 2 1 x)) (* 3 (c 0 0 y) (c 2 1 x)) (* (- 9) (c 1 1 x) (c 2 0 y)) (* 3 (c 0 1 x) (c 2 0 y)) (* 9 (c 1 1 y) (c 2 0 x)) (* (- 3) (c 0 1 y) (c 2 0 x)) (* (- 9) (c 1 0 x) (c 1 1 y)) (* 3 (c 0 0 x) (c 1 1 y)) (* 9 (c 1 0 y) (c 1 1 x)) (* (- 3) (c 0 0 y) (c 1 1 x)) (* (- 3) (c 0 1 x) (c 1 0 y)) (* 3 (c 0 1 y) (c 1 0 x)) (* (- (c 0 0 x)) (c 0 1 y)) (* (c 0 0 y) (c 0 1 x)))))
      (let ((s (nth-degree-solver (list p6 p5 p4 p3 p2 p1 p0) :min 0 :max 1)))
        (let ((denom (+ (* -1 (c 0 0 x)) (c 0 1 x) (* 3 (c 0 0 x) s) (* -3 (c 0 1 x) s) (* -3 (c 1 0 x) s) (* 3 (c 1 1 x) s) (* -3 (c 0 0 x) (expt s 2)) (* 3 (c 0 1 x) (expt s 2)) (* 6 (c 1 0 x) (expt s 2)) (* -6 (c 1 1 x) (expt s 2)) (* -3 (c 2 0 x) (expt s 2)) (* 3 (c 2 1 x) (expt s 2)) (* (c 0 0 x) (expt s 3)) (* -1 (c 0 1 x) (expt s 3)) (* -3 (c 1 0 x) (expt s 3)) (* 3 (c 1 1 x) (expt s 3)) (* 3 (c 2 0 x) (expt s 3)) (* -3 (c 2 1 x) (expt s 3)) (* -1 (c 3 0 x) (expt s 3)) (* (c 3 1 x) (expt s 3)))))
          (if (< (abs denom) *epsilon*)
              (list s (/ (- v (+ (c 0 0 y) (* -3 (c 0 0 y) s) (* 3 (c 1 0 y) s) (* 3 (c 0 0 y) (expt s 2)) (* -6 (c 1 0 y) (expt s 2)) (* 3 (c 2 0 y) (expt s 2)) (* -1 (c 0 0 y) (expt s 3)) (* 3 (c 1 0 y) (expt s 3)) (* -3 (c 2 0 y) (expt s 3)) (* (c 3 0 y) (expt s 3))))
                         (+ (* -1 (c 0 0 y)) (c 0 1 y) (* 3 (c 0 0 y) s) (* -3 (c 0 1 y) s) (* -3 (c 1 0 y) s) (* 3 (c 1 1 y) s) (* -3 (c 0 0 y) (expt s 2)) (* 3 (c 0 1 y) (expt s 2)) (* 6 (c 1 0 y) (expt s 2)) (* -6 (c 1 1 y) (expt s 2)) (* -3 (c 2 0 y) (expt s 2)) (* 3 (c 2 1 y) (expt s 2)) (* (c 0 0 y) (expt s 3)) (* -1 (c 0 1 y) (expt s 3)) (* -3 (c 1 0 y) (expt s 3)) (* 3 (c 1 1 y) (expt s 3)) (* 3 (c 2 0 y) (expt s 3)) (* -3 (c 2 1 y) (expt s 3)) (* -1 (c 3 0 y) (expt s 3)) (* (c 3 1 y) (expt s 3)))))
              (list s (/ (- u (+ (c 0 0 x) (* -3 (c 0 0 x) s) (* 3 (c 1 0 x) s) (* 3 (c 0 0 x) (expt s 2)) (* -6 (c 1 0 x) (expt s 2)) (* 3 (c 2 0 x) (expt s 2)) (* -1 (c 0 0 x) (expt s 3)) (* 3 (c 1 0 x) (expt s 3)) (* -3 (c 2 0 x) (expt s 3)) (* (c 3 0 x) (expt s 3))))
                         denom))))))))

;;; (reverse-cubic-parameters '(((0 0) (1 0) (2 0) (3 0)) ((0 3) (1 3) (2 3) (3 3))) '(2 4))

(defun reverse-bilinear-parameters (cpts p)
  "CPTS is ((B00 B10) (B01 B11)).
Returns parameters for which the Bezier patch given by CPTS evaluates to P."
  (macrolet ((c (i j coord)
               (if (eq coord 'x)
                   `(first (elt (elt cpts ,j) ,i))
                   `(second (elt (elt cpts ,j) ,i)))))
    (let* ((u (first p))
           (v (second p))
           (p0 (+ (* (- (c 0 1 x)) v) (* (c 0 0 x) v) (* (c 0 1 y) u) (* (- (c 0 0 y)) u) (* (- (c 0 0 x)) (c 0 1 y)) (* (c 0 0 y) (c 0 1 x))))
           (p1 (+ (* (- (c 1 1 x)) v) (* (c 1 0 x) v) (* (c 0 1 x) v) (* (- (c 0 0 x)) v) (* (c 1 1 y) u) (* (- (c 1 0 y)) u) (* (- (c 0 1 y)) u) (* (c 0 0 y) u) (* (- (c 0 0 x)) (c 1 1 y)) (* (c 0 0 y) (c 1 1 x)) (* (c 0 1 x) (c 1 0 y)) (* (- (c 0 1 y)) (c 1 0 x)) (* 2 (c 0 0 x) (c 0 1 y)) (* (- 2) (c 0 0 y) (c 0 1 x))))
           (p2 (+ (* (- (c 1 0 x)) (c 1 1 y)) (* (c 0 0 x) (c 1 1 y)) (* (c 1 0 y) (c 1 1 x)) (* (- (c 0 0 y)) (c 1 1 x)) (* (- (c 0 1 x)) (c 1 0 y)) (* (c 0 1 y) (c 1 0 x)) (* (- (c 0 0 x)) (c 0 1 y)) (* (c 0 0 y) (c 0 1 x))))
           (real-s nil))
      (flet ((try (s x u)
               (let ((denom (+ (* (+ (elt (elt (elt cpts 1) 1) x) (- (elt (elt (elt cpts 0) 1) x)) (- (elt (elt (elt cpts 1) 0) x)) (elt (elt (elt cpts 0) 0) x)) s) (elt (elt (elt cpts 1) 0) x) (- (elt (elt (elt cpts 0) 0) x)))))
                 (when (> (abs denom) *epsilon*)
                   (setf real-s s)
                   (/ (+ u (- (* (elt (elt (elt cpts 0) 1) x) s)) (* (elt (elt (elt cpts 0) 0) x) s) (- (* (elt (elt (elt cpts 0) 0) x))))
                      denom)))))
        (multiple-value-bind (s1 s2) (second-degree-solver p2 p1 p0)
          (let ((d (or (try s1 0 u) (try s1 1 v) (try s2 0 u) (try s2 1 v))))
            (list real-s d)))))))

;;; (reverse-bilinear-parameters '(((0 0) (1 0)) ((0 2) (2 3))) '(1.7 0.3))

(defun bezier-surface (cpts uv)
  (iter (with p = '(0 0 0))
        (with m = (1- (length cpts)))
        (with n = (1- (length (first cpts))))
        (for j from 0 to m)
        (iter (for i from 0 to n)
              (for cp = (elt (elt cpts j) i))
              (setf p (v+ p (v* cp (bernstein n i (first uv)) (bernstein m j (second uv))))))
        (finally (return p))))

(defun read-gbp (filename)
  (flet ((read-point (s)
           (let* ((x (read s))
                  (y (read s))
                  (z (read s)))
             (list x y z))))
    (with-open-file (s filename)
      (let* ((n (read s))
             (d (read s))
             (l (floor (1+ d) 2))
             (cp (1+ (* n (1+ (floor d 2)) l)))
             (center (read-point s)))
        (declare (ignore center))
        (iter (for i from 1 below cp)
              (for col first 0 then (1+ col))
              (with side = 0)
              (with row = 0)
              (when (>= col (- d row))
                (when (>= (incf side) n)
                  (setf side 0)
                  (incf row))
                (setf col row))
              (let ((p (read-point s)))
                (collect (list side col row p))
                (when (< col l)
                  (collect (list (mod (1- side) n) (- d row) col p)))
                (when (< (- d col) l)
                  (collect (list (mod (1+ side) n) row (- d col) p)))))))))

(defun load-ribbons (filename)
  (let ((gbp (read-gbp filename)))
    (flet ((c (i j k)
             (elt (find (list i j k) gbp :key (lambda (x) (subseq x 0 3)) :test #'equal) 3)))
      (iter (with n = (reduce #'max gbp :key #'first))
            (with d = (reduce #'max gbp :key #'second))
            (for i from 0 to n)
            (collect (iter (for k from 0 to 1)
                           (collect (iter (for j from 0 to d)
                                          (collect (c i j k))))))))))

(defun mirror-concave-corner (ribbons i &optional (alpha 1) (beta 1))
  "Creates a twist-compatible, coherent concave corner at sides I-1 and I.
Destructively modifies RIBBONS, and returns the two newly created bilinear patch,
the first one is to use with ribbon I-1, the second is with ribbon I.
ALPHA is used in the U direction of ribbon I-1, BETA in the -U direction of ribbon I."
  (flet ((mirror (p o s) (v+ o (v* (v- o p) s)))
         (p (i j k) (elt (elt (elt ribbons i) k) j))
         (setp (i j k p) (setf (elt (elt (elt ribbons i) k) j) p)))
    (let* ((n (length ribbons))
           (i-1 (mod (1- i) n))
           (corner (p i 0 0))
           (twist (p i 1 1)))
      (setp i-1 2 1 (mirror twist (p i-1 2 0) beta))
      (setp  i  1 1 (mirror twist (p i 1 0) alpha))
      (setp i-1 3 1 (mirror (p i 1 0) corner beta))
      (setp  i  0 1 (mirror (p i-1 2 0) corner alpha))
      (let ((inner-twist (mirror (p i 1 1) (p i 0 1) beta)))
        (list (list (list corner (p i 0 1))
                    (list (p i-1 3 1) inner-twist))
              (list (list (p i-1 3 1) corner)
                    (list inner-twist (p i 0 1))))))))

(defun write-bezier-ribbon-control-points (ribbons filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "~{~{~{v~{ ~f~}~%~}~}~}" ribbons)))

(defvar *dropbox* "/home/salvi/Dropbox")

#+nil
(let* ((ribbons (load-ribbons (format nil "~a~a" *dropbox* "/Shares/GrafGeo/Polar/bezier-ribbon/GBTest3_Cubic.gbp")))
       (bilinears (mirror-concave-corner ribbons 5 1 1)))
  (write-bezier-ribbon-control-points (append bilinears ribbons) "/tmp/pontok.obj")
  (let ((*resolution* 40)
        (domain '((0 6) (3 6) (3 3) (6 3) (6 0) (0 0)))
        (cubic '(((3 3) (3 4) (3 5) (3 6)) ((2 3) (2 4) (2 5) (2 6))))
        (linear '(((3 2) (3 3)) ((2 2) (2 3))))
        (cubic3d (elt ribbons 5))
        (linear3d (elt bilinears 1)))
    (flet ((ribbon (p)
             (if (<= (second p) 3)      ; works only on this domain...
                 (bezier-surface linear3d (reverse-bilinear-parameters linear p))
                 (bezier-surface cubic3d (reverse-cubic-parameters cubic p)))))
      (write-stl (eval3d-on-concave-domain domain #'ribbon)
                 "/tmp/proba.stl" :ascii t))))

#+nil
(let* ((ribbons (load-ribbons (format nil "~a~a" *dropbox* "/Shares/GrafGeo/Polar/bezier-ribbon/GBTest3_Cubic.gbp")))
       (bilinears (mirror-concave-corner ribbons 5 1 1)))
  (write-bezier-ribbon-control-points (append bilinears ribbons) "/tmp/pontok.obj")
  (let ((*resolution* 40)
        (domain '((0 6) (3 6) (3 3) (6 3) (6 0) (0 0)))
        (cubic '(((6 3) (5 3) (4 3) (3 3)) ((6 2) (5 2) (4 2) (3 2))))
        (linear '(((3 3) (2 3)) ((3 2) (2 2))))
        (cubic3d (elt ribbons 4))
        (linear3d (elt bilinears 0)))
    (flet ((ribbon (p)
             (if (and (<= (second p) 3) (>= (first p) 3)) ; works only on this domain...
                 (bezier-surface cubic3d (reverse-cubic-parameters cubic p))
                 (bezier-surface linear3d (reverse-bilinear-parameters linear p)))))
      (write-stl (eval3d-on-concave-domain domain #'ribbon)
                 "/tmp/proba.stl" :ascii t))))


;;; Only parameterization

#+nil
(let ((*resolution* 40)
      (domain '((0 6) (3 6) (3 3) (6 3) (6 0) (0 0)))
      (cubic '(((3 3) (3 4) (3 5) (3 6)) ((2 3) (2 4) (2 5) (2 6))))
      (linear '(((3 2) (3 3)) ((2 2) (2 3)))))
  (flet ((param (sd)
           (lambda (p)
             (if (< (second p) 3)       ; works only on this domain...
                 (elt (reverse-bilinear-parameters linear p) sd)
                 (elt (reverse-cubic-parameters cubic p) sd)))))
    (write-stl (eval-on-concave-domain domain (param 0))
               "/tmp/proba.stl" :ascii t)))


;;; Testing 3D ribbons

#+nil
(let ((*resolution* 40)
      (domain '((0 6) (3 6) (3 3) (6 3) (6 0) (0 0)))
      (cubic '(((3 3) (3 4) (3 5) (3 6)) ((2 3) (2 4) (2 5) (2 6))))
      (linear '(((3 2) (3 3)) ((2 2) (2 3))))
      (cubic3d '(((0 0 0) (10 5 4) (20 5 8) (30 0 0))
                 ((0 20 0) (8 18 5) (21 15 5) (30 20 0))))
      (linear3d '(((-10 -5 -4) (0 0 0))
                  ((-8 22 -5) (0 20 0))))
      ;; (cubic3d '(((0 0 0) (10 0 5) (20 0 5) (30 0 0))
      ;;            ((0 20 0) (10 20 10) (20 20 10) (30 20 0))))
      ;; (linear3d '(((-10 0 -5) (0 0 0))
      ;;             ((-10 20 -10) (0 20 0))))
      ;; (cubic3d '(((0 0 0) (10 0 0) (20 0 0) (30 0 0))
      ;;            ((0 20 0) (10 20 0) (20 20 00) (30 20 0))))
      ;; (linear3d '(((-10 0 0) (0 0 0))
      ;;             ((-10 20 0) (0 20 0))))
      )
  (flet ((ribbon (p)
           (if (<= (second p) 3)       ; works only on this domain...
               (bezier-surface linear3d (reverse-bilinear-parameters linear p))
               (bezier-surface cubic3d (reverse-cubic-parameters cubic p)))))
    (write-stl (eval3d-on-concave-domain domain #'ribbon)
               "/tmp/proba.stl" :ascii t)))
