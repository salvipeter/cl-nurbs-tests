(in-package :cl-nurbs-tests)

(defun concavep (points i)
  "Assumes that POINTS is given in positive order, i.e. `matter' is on the left side."
  (let* ((n (length points))
         (im (mod (1- i) n))
         (ip (mod (1+ i) n))
         (u (vnormalize (v- (elt points ip) (elt points i))))
         (v (vnormalize (v- (elt points im) (elt points i)))))
    (>= (- (* (elt u 0) (elt v 1))
           (* (elt u 1) (elt v 0)))
       0)))

(defun snip-triangle (points i)
  (append (subseq points 0 i)
          (subseq points (1+ i))))

(defun mesh-triangle (points i)
  (let* ((n (length points))
         (a (elt points (mod (1- i) n)))
         (b (elt points i))
         (c (elt points (mod (1+ i) n))))
    (iter (for i from 1 to *resolution*)
          (for u = (/ i *resolution*))
          (for p = (affine-combine b u a))
          (for q = (affine-combine b u c))
          (for last-row first (list (list b)) then (nreverse row))
          (for row = '())
          (appending
           (iter (for j from 0 below i)
                 (for tri = (list (affine-combine p (/ j i) q)
                                  (affine-combine p (/ (1+ j) i) q)
                                  (if (= j 0)
                                      (elt (elt last-row j) 0)
                                      (elt (elt last-row (1- j)) 1))))
                 (push tri row)
                 (collect tri)
                 (unless (= j 0)
                   (collect (list (affine-combine p (/ j i) q)
                                  (elt (elt last-row (1- j)) 1)
                                  (elt (elt last-row (1- j)) 0)))))))))

(defun segment-segment-intersection (a b)
  "Returns NIL if there is no intersection point."
  (destructuring-bind (q1 q2) a
    (let* ((p (first b))
           (v (v- (second b) (first b)))
           (i (if (> (abs (first v)) (abs (second v))) 0 1)))
      (macrolet ((x (var) `(elt ,var i))
                 (y (var) `(elt ,var (- 1 i))))
        (let ((denom (- (* (x v) (- (y q2) (y q1)))
                        (* (y v) (- (x q2) (x q1))))))
          (unless (< (abs denom) *epsilon*)
            (let ((u (/ (+ (* (x v) (- (y p) (y q1)))
                           (* (y v) (- (x q1) (x p))))
                        denom)))
              (unless (or (< u (- *epsilon*)) (> u (1+ *epsilon*)))
                (let* ((u1 (min (max u 0) 1))
                       (u2 (/ (+ (- (x q1) (x p))
                                 (* (- (x q2) (x q1)) u1))
                              (x v))))
                  (unless (or (< u2 (- *epsilon*)) (> u2 (1+ *epsilon*)))
                    (v+ q1 (v* (v- q2 q1) u1))))))))))))

(defun snippablep (points i)
  "Returns T if the segment from i-1 to i+1 does not intersect the polygon"
  (let* ((n (length points))
         (i-1 (mod (1- i) n))
         (i+1 (mod (1+ i) n)))
    (iter (for j from 0 below n)
          (for j+1 = (mod (1+ j) n))
          (when (and (/= j (mod (- i 2) n)) (/= j i-1) (/= j i) (/= j i+1)
                     (segment-segment-intersection
                      (list (elt points i-1) (elt points i+1))
                      (list (elt points j) (elt points j+1))))
            (return-from snippablep nil))))
  t)

(defun mesh-concave (points)
  (iter (with points = (copy-list points))
        (while (>= (length points) 3))
        (for i = (or (iter (with n = (length points))
                           (for j from 0 below n)
                           (when (and (not (concavep points j))
                                      (or (concavep points (mod (1- j) n))
                                          (concavep points (mod (1+ j) n)))
                                      (snippablep points j))
                             (return j)))
                     (iter (with n = (length points))
                           (for j from 0 below n)
                           (when (snippablep points j)
                             (return j)))))
        (appending (mesh-triangle points i))
        (setf points (snip-triangle points i))))

#+nil
(labels ((to3d-pt (p) (append p '(0)))
         (to3d-tri (tri) (mapcar #'to3d-pt tri))
         (to3d (tris) (mapcar #'to3d-tri tris)))
  (let ((*resolution* 20)
        (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3))))
    (write-stl (to3d (mesh-concave points)) "/tmp/proba.stl" :ascii t)))

(defun eval-on-concave-domain (points fn)
  (let ((mesh (mesh-concave points)))
    (mapcar (lambda (tri)
              (mapcar (lambda (p)
                        (cons (funcall fn p) p))
                      tri))
            mesh)))

#+nil
(let ((*resolution* 20)
        (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3))))
  (flet ((fn (p)
           (mean-value points (cons 1 (make-list (1- (length points)) :initial-element 0)) p)))
    (write-stl (eval-on-concave-domain points #'fn) "/tmp/proba.stl" :ascii t)))

(defun mean-value-coordinates (points p)
  (let* ((vectors (mapcar (lambda (x) (v- p x)) points))
         (lengths (mapcar #'vlength vectors))
         (n (length points)))
    (labels ((inc (i) (mod (1+ i) n))
             (dec (i) (mod (1- i) n))
             (area (i)                  ; signed area = det(si,si+1)/2
               (let ((si (elt vectors i))
                     (si+1 (elt vectors (inc i))))
                 (/ (- (* (elt si 0) (elt si+1 1))
                       (* (elt si 1) (elt si+1 0)))
                    2.0d0))))
      (let* ((w (iter (for i from 0 below n)
                      (for Ai = (area i))
                      (for Ai-1 = (area (dec i)))
                      (for Di = (scalar-product (elt vectors (inc i)) (elt vectors i)))
                      (for Di-1 = (scalar-product (elt vectors i) (elt vectors (dec i))))
                      (for ri-1 = (elt lengths (dec i)))
                      (for ri = (elt lengths i))
                      (for ri+1 = (elt lengths (inc i)))
                      (when (< (abs ri) *epsilon*)
                        (let ((result (make-list n :initial-element 0)))
                          (setf (elt result i) 1)
                          (return-from mean-value-coordinates result)))
                      (when (and (< (abs Ai) *epsilon*)
                                 (< Di (- *epsilon*)))
                        (let ((result (make-list n :initial-element 0)))
                          (setf (elt result i) (/ ri+1 (+ ri ri+1))
                                (elt result (inc i)) (/ ri (+ ri ri+1)))
                          (return-from mean-value-coordinates result)))
                      (collect (+ (if (> (abs Ai-1) *epsilon*)
                                      (/ (- ri-1 (/ Di-1 ri)) Ai-1)
                                      0)
                                  (if (> (abs Ai) *epsilon*)
                                      (/ (- ri+1 (/ Di ri)) Ai)
                                      0)))))
             (wsum (reduce #'+ w)))
        (mapcar (lambda (wi) (/ wi wsum)) w)))))

(defun mean-kato (points i)
  (lambda (p)
    (let* ((l (mean-value-coordinates points p))
           (d (iter (with n = (length l))
                    (for i from 0 below n)
                    (for i-1 = (mod (1- i) n))
                    (collect (- 1 (elt l i-1) (elt l i))))))
      (assert (every (lambda (x) (>= x -1.0d-6)) d))
      (ribbon-blend d i))))

(defun mean-sweep (points i)
  (lambda (p)
    (let* ((n (length points))
           (i-1 (mod (1- i) n))
           (i+1 (mod (1+ i) n))
           (l (mean-value-coordinates points p))
           (d (iter (for i from 0 below n)
                    (for i-1 = (mod (1- i) n))
                    (collect (- 1 (elt l i-1) (elt l i))))))
      (safe-/ (elt d i-1) (+ (elt d i-1) (elt d i+1))))))

(defun mean-bernstein (points i j k)
  "Bivariate cubic Bernstein function B^3_j * B^3_k using the above parameters."
  (lambda (p)
    (let* ((n (length points))
           (i-1 (mod (1- i) n))
           (i+1 (mod (1+ i) n))
           (l (mean-value-coordinates points p))
           (d (iter (for i from 0 below n)
                    (for i-1 = (mod (1- i) n))
                    (collect (- 1 (elt l i-1) (elt l i)))))
           (si (safe-/ (elt d i-1) (+ (elt d i-1) (elt d i+1))))
           (di (elt d i)))
      (* (bernstein 3 j si) (bernstein 3 k di)))))

#+nil
(let ((*resolution* 50)
      ;; (points '((0 0) (0 7) (1 7) (1 4) (2 4) (2 7) (3 7) (3 4) (4 4) (4 7) (5 7)
      ;;           (5 0) (4 0) (4 3) (3 3) (3 0) (2 0) (2 3) (1 3) (1 0)))
      ;; (points '((0 0) (0 7) (1 7) (1 4) (2 4) (2 7) (3 7) (3 0) (2 0) (2 3) (1 3) (1 0)))
      ;; (points '((2 5) (3 3) (5 3) (6 5) (8 3) (7 0) (1 0) (0 3)))
      (points '((1 2) (1 1) (2 1) (2 0) (0 0) (0 2)))
      )
  (dotimes (j 4)
    (dotimes (k 2)
      (write-stl (eval-on-concave-domain points (mean-bernstein points 1 j k))
                 (format nil "/tmp/b~a~a.stl" j k) :ascii t))))
