(in-package :cl-nurbs-tests)

(defparameter *width* 640)
(defparameter *height* 480)
(defparameter *line-width* 2.0d0)
(defparameter *point-size* 3.0d0)
(defparameter *density* 50.0d0)
(defparameter *tolerance* 1.0d0)
(defparameter *epsilon* 1.0d-5)
(defparameter *colors*
  '((on-line . (0 0 0))
    (outside . (255 255 255))
    (nothing . (255 255 255))
    (si . (255 0 0))
    (di . (0 200 0))
    (si-1 . (0 0 255))
    (di-1 . (255 0 255))))

(defun kato-test (p1 p2 filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "P2~%~d ~d~%255~%" *width* *height*)
    (iter (with length = (point-distance p1 p2))
	  (for y from 0 below *height*)
	  (iter (for x from 0 below *width*)
		(unless (zerop x)
		  (princ #\Space s))
		(for p = (list x y))
		(for p1d = (point-distance p p1))
		(for p2d = (point-distance p p2))
		(for distance = (+ p1d p2d (- length)))
		(cond ((and (< (abs distance) *line-width*)
			    (< p1d length) (< p2d length))
		       (princ (floor (* (abs distance) 255) *line-width*) s))
		      ((< (mod distance *density*) *line-width*)
		       (princ 0 s))
		      (t (princ 255 s))))
	  (terpri s))))

(defun on-segment-p (q1 q2 x y)
  "Test whether the point (X Y) is on the segment defined by Q1 and Q2."
  (let ((p (list x y))
	(dir (vnormalize (v- q2 q1))))
    (and (< (point-distance p (v+ q1 (v* dir (scalar-product (v- p q1) dir))))
	    *tolerance*)
	 (< (max (point-distance p q1)
		 (point-distance p q2))
	    (point-distance q1 q2)))))

(defun kato-test-2 (p0 p1 p2 p3 filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "P2~%~d ~d~%2~%" *width* *height*)
    (let ((length1 (point-distance p0 p1))
	  (length2 (point-distance p2 p3)))
      (labels ((parameter (x y)
		 (let* ((p (list x y))
			(p0d (point-distance p p0))
			(p1d (point-distance p p1))
			(p2d (point-distance p p2))
			(p3d (point-distance p p3))
			(distance1 (+ p0d p1d (- length1)))
			(distance2 (+ p2d p3d (- length2))))
		   (/ distance1 (+ distance1 distance2))))
	       (better-points (x y base)
		 (iter (for i from -1 to 1)
		       (sum (iter (for j from -1 to 1)
				  (for current =
				       (mod (parameter (+ x i) (+ y j))
					    *density*))
				  (count (< current base)))))))
	(iter (for y from 0 below *height*)
	      (iter (for x from 0 below *width*)
		    (unless (zerop x)
		      (princ #\Space s))
		    (for current = (mod (parameter x y) *density*))
		    (cond ((or (on-segment-p p0 p1 x y)
			       (on-segment-p p1 p2 x y)
			       (on-segment-p p2 p3 x y))
			   (princ 0 s))
			  ((and (< current *line-width*)
				(<= (better-points x y current) 2))
			   (princ 1 s))
			  (t (princ 2 s))))
	      (terpri s))))))

(defun center-line (w0 w2 length center)
  "Both W0, W2 and CENTER are in local coordinates."
  (let* ((s (v* (v+ w0 w2) 1/2))
	 (alpha (/ (second center) (second s))))
    (list (- (/ (- (* 2 (first center)) length) alpha) (first s)) (second s))))

(defun line-sweep (w0 w1 w2 length p)
  (let ((a (+ (* length (- (second w2) (second w0)))
	      (* (second p) (+ (first w2) (* -2 (first w1)) (first w0)))))
	(b (+ (* length (second w0))
	      (* (first p) (- (second w0) (second w2)))
	      (* 2 (second p) (- (first w1) (first w0)))))
	(c (- (* (second p) (first w0)) (* (first p) (second w0)))))
    (second-degree-solver a b c :min 0.0d0 :max 1.0d0)))

(defun central-line-sweep (p0 p1 p2 p3 center filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "P2~%~d ~d~%2~%" *width* *height*)
    (let* ((base-x (vnormalize (v- p2 p1)))
	   (base-y (list (- (second base-x)) (first base-x)))
	   (length (point-distance p1 p2))
	   (w0 (in-system base-x base-y (v- p0 p1)))
	   (w2 (in-system base-x base-y (v- p3 p2)))
	   (w1 (center-line w0 w2 length
			    (in-system base-x base-y (v- center p1)))))
      (labels ((parameter (x y)
		 (line-sweep w0 w1 w2 length
			     (in-system base-x base-y (v- (list x y) p1))))
	       (better-points (x y base)
		 (iter (for i from -1 to 1)
		       (sum (iter (for j from -1 to 1)
				  (for current =
				       (mod (parameter (+ x i) (+ y j))
					    *density*))
				  (count (< current base)))))))
	(iter (for y from 0 below *height*)
	      (iter (for x from 0 below *width*)
		    (unless (zerop x)
		      (princ #\Space s))
		    (for current = (mod (parameter x y) *density*))
		    (cond ((or (on-segment-p p0 p1 x y)
			       (on-segment-p p1 p2 x y)
			       (on-segment-p p2 p3 x y)
			       (< (point-distance (list x y) center)
				  *point-size*))
			   (princ 0 s)) 
			  ((and (< current *line-width*)
				(<= (better-points x y current) 2))
			   (princ 1 s))
			  (t (princ 2 s))))
	      (terpri s))))))

(defun radial-test (p0 p1 p2 p3 filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "P2~%~d ~d~%2~%" *width* *height*)
    (let* ((base-x (vnormalize (v- p2 p1)))
	   (base-y (list (- (second base-x)) (first base-x)))
	   (a (in-system base-x base-y (v- p0 p1)))
	   (b (in-system base-x base-y (v- p3 p2)))
	   (length (point-distance p1 p2))
	   (axby-aybx (- (* (first a) (second b)) (* (second a) (first b))))
	   (laxby-div (/ (* length (first a) (second b)) axby-aybx))
	   (layby-div (/ (* length (second a) (second b)) axby-aybx)))
      (labels ((parameter (x y)
		 (destructuring-bind (x y)
		     (in-system base-x base-y (v- (list x y) p1))
		   (/ (+ x (* (/ y (- y layby-div)) (- laxby-div x))) length)))
	       (better-points (x y base)
		 (iter (for i from -1 to 1)
		       (sum (iter (for j from -1 to 1)
				  (for current =
				       (mod (parameter (+ x i) (+ y j))
					    *density*))
				  (count (< current base)))))))
	(iter (for y from 0 below *height*)
	      (iter (for x from 0 below *width*)
		    (unless (zerop x)
		      (princ #\Space s))
		    (for current = (mod (parameter x y) *density*))
		    (cond ((or (on-segment-p p0 p1 x y)
			       (on-segment-p p1 p2 x y)
			       (on-segment-p p2 p3 x y))
			   (princ 0 s))
			  ((and (< current *line-width*)
				(<= (better-points x y current) 2))
			   (princ 1 s))
			  (t (princ 2 s))))
	      (terpri s))))))

(defgeneric compute-distance (type points segments p dir))

(defmethod compute-distance ((type (eql 'perpendicular)) points segments p dir)
  (let ((p0 (elt segments 1))
	(p1 (elt segments 2)))
    (if (eq dir 'd)
	(/ (point-line-distance p (list p0 p1))
	   (iter (for q1 in points)
		 (maximize (iter (for q2 in points)
				 (maximize (point-distance q1 q2))))))
	(let ((di-1 (point-line-distance p (list (elt segments 0) p0)))
	      (di+1 (point-line-distance p (list p1 (elt segments 3)))))
	  (/ di-1 (+ di-1 di+1))))))

(defmethod compute-distance ((type (eql 'barycentric)) points segments p dir)
  (let ((lines (lines-from-points points)))
    (flet ((area (segment)
	     (let* ((a (point-distance p (first segment)))
		    (b (point-distance p (second segment)))
		    (c (apply #'point-distance segment))
		    (s (/ (+ a b c) 2)))
	       (sqrt (max 0 (* s (- s a) (- s b) (- s c)))))))
      (if (eq dir 'd)
	  (* (/ (area (subseq segments 1 3))
		(reduce #'+ (mapcar #'area lines)))
	     (/ (length lines) 2))
	  (let ((di-1 (area (subseq segments 0 2)))
		(di+1 (area (subseq segments 2))))
	    (/ di-1 (+ di-1 di+1)))))))

(defmethod compute-distance ((type (eql 'chord-based)) points segments p dir)
  (if (eq dir 'd)
      (let* ((length (point-distance (second segments) (third segments)))
	     (p1d (point-distance p (second segments)))
	     (p2d (point-distance p (third segments))))
	(/ (+ p1d p2d (- length))
	   (iter (for q1 in points)
		 (maximize (iter (for q2 in points)
				 (maximize (point-distance q1 q2)))))))
      (let* ((length1 (point-distance (first segments) (second segments)))
	     (length2 (point-distance (third segments) (fourth segments)))
	     (p0d (point-distance p (first segments)))
	     (p1d (point-distance p (second segments)))
	     (p2d (point-distance p (third segments)))
	     (p3d (point-distance p (fourth segments)))
	     (distance1 (+ p0d p1d (- length1)))
	     (distance2 (+ p2d p3d (- length2))))
	(/ distance1 (+ distance1 distance2)))))

(defun radial-intersection (segments p)
  (let* ((p0 (first segments))
	 (p1 (second segments))
	 (p2 (third segments))
	 (p3 (fourth segments))
	 (base-x (vnormalize (v- p2 p1)))
	 (base-y (list (- (second base-x)) (first base-x)))
	 (a (in-system base-x base-y (v- p0 p1)))
	 (b (in-system base-x base-y (v- p3 p2)))
	 (length (point-distance p1 p2))
	 (axby-aybx (- (* (first a) (second b)) (* (second a) (first b)))))
    (if (< (abs axby-aybx) *epsilon*)
	(let ((slength (scalar-product (v- p p1) base-x)))
	  (values (/ slength length) (v+ p1 (v* base-x slength))))
	(let ((laxby-div (/ (* length (first a) (second b)) axby-aybx))
	      (layby-div (/ (* length (second a) (second b)) axby-aybx)))
	  (destructuring-bind (x y)
	      (in-system base-x base-y (v- p p1))
	    (let ((x0 (if (< (abs (- y layby-div)) *epsilon*)
			  0.5 ; kutykurutty the point is the focus itself
			  (+ x (* (/ y (- y layby-div)) (- laxby-div x))))))
	      (values (/ x0 length) (v+ p1 (v* base-x x0)))))))))

(defmethod compute-distance ((type (eql 'radial)) points segments p dir)
  (multiple-value-bind (s q) (radial-intersection segments p)
    (if (eq dir 'd)
	(/ (point-distance p q)
	   (iter (for q1 in points)
		 (maximize (iter (for q2 in points)
				 (maximize (point-distance q1 q2))))))
	s)))

(defun segments-prev (points segments)
  (let ((i (position (first segments) points :test #'equal)))
    (cons (elt points (mod (1- i) (length points)))
	  (butlast segments))))

(defun segments-next (points segments)
  (let ((i (position (first segments) points :test #'equal)))
    (append (rest segments)
	    (list (elt points (mod (+ i 4) (length points)))))))

(defparameter +hermite-blend+ (lambda (x) (hermite-blend-function 'point 'start x)))
(defparameter +distance-blend+ (lambda (x) (blend (list x (- 1.0d0 x)) 0)))
(defparameter +peti-blend+ (lambda (x) (interior-blend (list x (- 1.0d0 x)) 0))) ; try alpha=-3/2

(defmacro defmodified-distance (distance blend-fn)
  "Warning: parameters are evaluated multiple times."
  `(defmethod compute-distance ((type (eql ',(intern (format nil "~:@(~a~)-MOD" distance))))
				points segments p dir)
     (let ((si (compute-distance ',distance points segments p 's)))
       (if (eq dir 's)
	   si
	   (let ((si-1 (compute-distance ',distance points
					 (segments-prev points segments)
					 p 's)) 
		 (si+1 (compute-distance ',distance points
					 (segments-next points segments)
					 p 's)))
	     (+ (* (- 1.0d0 si-1) (funcall ,blend-fn si))
		(* si+1 (funcall ,blend-fn (- 1.0d0 si)))))))))

(defmodified-distance radial +distance-blend+)
(defmodified-distance perpendicular +distance-blend+)
(defmodified-distance barycentric +distance-blend+)
(defmodified-distance chord-based +distance-blend+)
(defmodified-distance line-sweep +distance-blend+)
(defmodified-distance bilinear +distance-blend+)

(defun bilinear-parameterization (segments p)
  (let* ((p0 (first segments))
	 (p1 (second segments))
	 (p2 (third segments))
	 (p3 (fourth segments))
	 (base-x (vnormalize (v- p2 p1)))
	 (base-y (list (- (second base-x)) (first base-x)))
	 (a (in-system base-x base-y (v- p0 p1)))
	 (b (in-system base-x base-y (v- p3 p2)))
	 (length (point-distance p1 p2)))
    (destructuring-bind (u v) (in-system base-x base-y (v- p p1))
      (let* ((s (second-degree-solver
		 (* length (- (second a) (second b)))
		 (+ (* u (second b)) (* -1 (+ u length) (second a)) (* (- (first a) (first b)) v))
		 (- (* u (second a)) (* v (first a)))
		 :min 0 :max 1))
	     (d (/ v (+ (* (- 1 s) (second a)) (* s (second b))))))
	(list s d)))))

(defmethod compute-distance ((type (eql 'bilinear)) points segments p dir)
  (declare (ignore points))
  (let ((sd (bilinear-parameterization segments p)))
    (if (eq dir 's)
	(first sd)
	(second sd))))

(defun solve-linear-two-variable (a1 b1 c1 a2 b2 c2)
  "Two linear equations of the form Ai*x + Bi*y + Ci = 0.
Returns (x y)."
  (let ((d (- (* b2 a1) (* b1 a2))))
    (if (< (abs d) *epsilon*)
	(if (< (abs (- (* b2 c1) (* b1 c2))) *epsilon*)
	    (cond ((> (abs b1) *epsilon*) (list 0 (/ (- c1) b1)))
		  ((> (abs b2) *epsilon*) (list 0 (/ (- c2) b2)))
		  ((> (abs a1) *epsilon*) (list (/ (- c1) a1) 0))
		  ((> (abs a2) *epsilon*) (list (/ (- c2) a2) 0))
		  ((and (< (abs c1) *epsilon*) (< (abs c2) *epsilon*)) '(0 0))
		  (t (error "No solutions (0-variable case)")))
	    (error "No solutions (1-variable case)"))
	(list (/ (- (* c2 b1) (* c1 b2)) d)
	      (/ (- (* c1 a2) (* c2 a1)) d)))))

(defun handle-point-on-side (p q1 q2 from to)
  (let* ((dir (vnormalize (v- q2 q1)))
	 (n (list (- (second dir)) (first dir))))
    (when (< (scalar-product (v- p q1) n) *epsilon*)
      (interpolate from
		   (/ (point-distance p q1) (point-distance q2 q1))
		   to))))

(defun handle-point-on-sides (segments p)
  "Use linear interpolation on the three defining sides to compute d,
or return NIL if the point is not on either side."
  (or (handle-point-on-side p (first segments) (second segments) 1 0)
      (handle-point-on-side p (second segments) (third segments) 0 0)
      (handle-point-on-side p (third segments) (fourth segments) 0 1)))

(defparameter *proportion* 0.5d0)
(defmethod compute-distance ((type (eql 'bilinear-new)) points segments p dir)
  "kutykurutty This idea seems to be flawed as well."
  (let ((s (first (bilinear-parameterization segments p))))
    (if (eq dir 's)
	s
	(or (handle-point-on-sides segments p)
	    (dlet* (((p-1 p0 p1 p2) (segments-prev points segments))
		    ((p1 p2 p3 p4) (segments-next points segments))
		    (s1 s)
		    (s2 (- 1 s))
		    (hs1 (funcall +hermite-blend+ s1))
		    (hs2 (funcall +hermite-blend+ s2))
		    (w1 *proportion*)
		    (w2 *proportion*)
		    (a (v* (v+ (v- p1 p0)
			       (v* (v+ (v- p0 p-1) (v- p2 p1)) s1 w1))
			   hs1))
		    (b (v* (v+ (v- p2 p3)
			       (v* (v+ (v- p3 p4) (v- p1 p2)) s2 w2))
			   hs2))
		    (c (v+ (v* (v+ p0 (v* (v- p-1 p0) s1 w1)) hs1)
			   (v* (v+ p3 (v* (v- p4 p3) s2 w2)) hs2)))
		    ((d1 d2) (solve-linear-two-variable
			      (first a) (first b) (- (first c) (first p))
			      (second a) (second b) (- (second c) (second p)))))
	      (+ (* (- 1 d1) (funcall +hermite-blend+ s))
		 (* (- 1 d2) (funcall +hermite-blend+ (- 1 s)))))))))

(defun nth-degree-solver (coefficients &key min max)
  "TODO: MIN and MAX are mandatory for the time being.
Strict checking is turned off."
  (let* ((start (iter (for i upfrom 0)
                      (for x in coefficients)
                      (while (< (abs x) *epsilon*))
                      (finally (return i))))
         (coeff (mapcar (lambda (x) (coerce x 'double-float))
                        (nreverse (subseq coefficients start))))
         (n (length coeff))
         (result (gsll:polynomial-solve
                  (grid:make-foreign-array 'double-float :dimensions n
                                           :initial-contents coeff)))
         (values (iter (for i from 0 below (1- n))
                       (for x = (grid:gref result i))
                       (when (< (abs (imagpart x)) *epsilon*)
                         (collect (realpart x)))))
         (good (iter (for x in values)
                     (when (<= min x max)
                       (collect x)))))
    (if good
        (progn
          (when (> (length good) 1)
            (warn "More than one eligible solutions for ~dth degree equation:~%~a" (1- n) good))
          (iter (for x in good)
                (with mean = (/ (+ min max) 2))
                (finding x minimizing (min (abs (- x mean))))))
        (iter (for x in values)
              (when (or (< (abs (- x min)) *epsilon*)
                        (< (abs (- x max)) *epsilon*))
                (return x))
              (finally
               #+nil(warn "No eligible solutions for ~dth degree equation:~%~a" (1- n) result)
               (return
                 (iter (for x in values)
                       (finding x minimizing (min (abs (- x min)) (abs (- x max)))))))))))

(defun one-sided-parabola-sweep (points segments p leftp)
  (dlet* (((p-1 p0 p1 p2) (segments-prev points segments))
	  ((p1 p2 p3 p4) (segments-next points segments))
	  (base-x (vnormalize (v- p2 p1)))
	  (base-y (list (- (second base-x)) (first base-x)))
	  (l (if leftp *proportion* (- 1 *proportion*)))
	  (a (in-system base-x base-y (v- p0 p1)))
	  (b (in-system base-x base-y
			(v- (if leftp
				(affine-combine p0 l p-1)
				(affine-combine p4 l p3))
			    p1)))
	  (c (in-system base-x base-y (v- p3 p1)))
	  (d (in-system base-x base-y (v- p2 p1)))
	  (local-p (in-system base-x base-y (v- p p1)))
	  (((ax ay) (bx by) (cx cy) (dx dy) (x y)) (list a b c d local-p))
	  (2ldx (* 2 l dx))
	  (s (nth-degree-solver
	      `(,( * (- dx 2ldx) (+ ay (* -2 by) cy))
                 ,(+ (* (+ ay (* -2 by) cy) 2ldx)
                     (* (- dx 2ldx) 2 (- by ay)))
                 ,(+ (* (+ ax (* -2 bx) cx) y)
                     (* (+ ay (* -2 by) cy) (- x))
                     (* (+ (* -2 ay) (* 2 by)) 2ldx)
                     (* (- dx 2ldx) (- ay y)))
                 ,(+ (* (+ (* -2 ax) (* 2 bx) (- 2ldx)) y)
                     (* (+ (* -2 ay) (* 2 by)) (- x))
                     (* ay 2ldx))
                 ,(- (* ax y) (* ay x)))
	      :min 0 :max 1))
	  (1-s (- 1 s)))
    (list s (/ y (+ (* ay 1-s 1-s) (* by 2 s 1-s) (* cy s s))))))

(defmethod compute-distance ((type (eql 'two-parabola)) points segments p dir)
  (let ((s (first (bilinear-parameterization segments p))))
    (if (eq dir 's)
	s
	(or (handle-point-on-sides segments p)
	    (dlet* (((s1 d1) (one-sided-parabola-sweep points segments p t))
		    ((s2 d2) (one-sided-parabola-sweep points segments p nil)))
	      (+ (* (funcall +hermite-blend+ s) d1)
		 (* (funcall +hermite-blend+ (- 1 s)) d2)))))))

(defmethod compute-distance ((type (eql 'linear-cubic)) points segments p dir)
  (let ((s (first (bilinear-parameterization segments p))))
    (if (eq dir 's)
        s
        (or (handle-point-on-sides segments p)
            (dlet* (((p-1 p0 p1 p2) (segments-prev points segments))
                    ((p1 p2 p3 p4) (segments-next points segments))
                    (base-x (vnormalize (v- p2 p1)))
                    (base-y (list (- (second base-x)) (first base-x)))
                    (l (point-distance p1 p2))
                    (a (in-system base-x base-y (v- p0 p1)))
                    (b (in-system base-x base-y
                                  (v- (affine-combine p0 *proportion* p-1) p1)))
                    (c (in-system base-x base-y
                                  (v- (affine-combine p3 *proportion* p4) p1)))
                    (d (in-system base-x base-y (v- p3 p1)))
                    (local-p (in-system base-x base-y (v- p p1)))
                    (q0 a)
                    (q1 (v* (v- b a) 3))
                    (q2 (v* (v+ a (v* b -2) c) 3))
                    (q3 (v+ (v* a -1) (v* b 3) (v* c -3) d))
                    (l1 (* 3 *proportion* l))
                    (l2 (* (- 3 (* 9 *proportion*)) l))
                    (l3 (* (- (* 6 *proportion*) 2) l))
                    ((x y) local-p)
                    (s (nth-degree-solver
                        `(,( * (second q3) l3)
                           ,(+ (* (second q3) l2)
                               (* (second q2) l3))
                           ,(+ (* (second q3) l1)
                               (* (second q2) l2)
                               (* (second q1) l3))
                           ,(+ (* y (- (first q3) l3))
                               (* -1 x (second q3))
                               (* (second q2) l1)
                               (* (second q1) l2)
                               (* (second q0) l3))
                           ,(+ (* y (- (first q2) l2))
                               (* -1 x (second q2))
                               (* (second q1) l1)
                               (* (second q0) l2))
                           ,(+ (* y (- (first q1) l1))
                               (* -1 x (second q1))
                               (* (second q0) l1))
                           ,(+ (* y (first q0))
                               (* -1 x (second q0))))
                        :min 0 :max 1))
                    (1-s (- 1 s)))
              (/ y (+ (* (second a) 1-s 1-s 1-s)
                      (* (second b) 3 1-s 1-s s)
                      (* (second c) 3 1-s s s)
                      (* (second d) s s s))))))))

(defmethod compute-distance ((type (eql 'linear-quadratic)) points segments p dir)
  "Flawed theory."
  (assert (= (length points) 5) () "Linear-Quadratic sweep works only for 5-sided patches")
  (let ((s (first (bilinear-parameterization segments p))))
    (if (eq dir 's)
        s
        (or (handle-point-on-sides segments p)
            (dlet* (((p-1 p0 p1 p2) (segments-prev points segments))
                    ((p1 p2 p3 p4) (segments-next points segments))
                    (base-x (vnormalize (v- p2 p1)))
                    (base-y (list (- (second base-x)) (first base-x)))
                    (l (point-distance p1 p2))
                    (a (in-system base-x base-y (v- p0 p1)))
                    (b (in-system base-x base-y (v- p-1 p1)))
                    (c (in-system base-x base-y (v- p3 p1)))
                    (local-p (in-system base-x base-y (v- p p1)))
                    (q0 a)
                    (q1 (v* (v- b a) 2))
                    (q2 (v+ a (v* b -2) c))
                    ((x y) local-p)
                    (s (nth-degree-solver
                        `(,( * (second q2) l)
                           ,(+ (* y (first q2))
                               (* -1 x (second q2))
                               (* l (second q1)))
                           ,(+ (* y (- (first q1) l))
                               (* -1 x (second q1))
                               (* l (second q0)))
                           ,(+ (* y (first q0))
                               (* -1 x (second q0))))
                        :min 0 :max 1))
                    (1-s (- 1 s)))
              (/ y (+ (* (second a) 1-s 1-s)
                      (* (second b) 2 1-s s)
                      (* (second c) s s))))))))

(defun parallelp (l1 l2)
  (let ((d (vnormalize (v- (second l1) (first l1)))))
    (< (abs (scalar-product (list (- (second d)) (first d))
                            (vnormalize (v- (second l2) (first l2)))))
       *epsilon*)))

(defun line-line-intersection (l1 l2)
  (if (parallelp l1 l2)
      (affine-combine (first l1) 1/2 (first l2))
      (destructuring-bind (((x1 y1) (x2 y2)) ((x3 y3) (x4 y4))) (list l1 l2)
	(list (/ (- (* (- (* x1 y2) (* y1 x2)) (- x3 x4))
		    (* (- (* x3 y4) (* y3 x4)) (- x1 x2)))
		 (- (* (- x1 x2) (- y3 y4)) (* (- y1 y2) (- x3 x4))))
	      (/ (- (* (- (* x1 y2) (* y1 x2)) (- y3 y4))
		    (* (- (* x3 y4) (* y3 x4)) (- y1 y2)))
		 (- (* (- x1 x2) (- y3 y4)) (* (- y1 y2) (- x3 x4))))))))

(defmethod compute-distance ((type (eql 'new-interconnected)) points segments p dir)
  (destructuring-bind (s d) (bilinear-parameterization segments p)
    (if (eq dir 's)
        s
        (or (handle-point-on-sides segments p)
            (dlet* ((prev-segments (segments-prev points segments))
                    (next-segments (segments-next points segments))
                    ((p-1 p0 p1 p2) prev-segments)
                    ((p1 p2 p3 p4) next-segments)
                    (mid (list (v+ p1 (v* (v- p0 p1) d))
                               (v+ p2 (v* (v- p3 p2) d))))
                    (left (list (v+ p1 (v* (v- p2 p1) s))
                                (v+ p0 (v* (v- p-1 p0) s))))
                    (right (list (v+ p1 (v* (v- p2 p1) s))
                                 (v+ p4 (v* (v- p3 p4) s))))
                    (a (line-line-intersection mid left))
                    (b (line-line-intersection mid right))
                    (d1 (- 1 (first (bilinear-parameterization prev-segments a))))
                    (d2 (first (bilinear-parameterization next-segments b))))
              (+ (* (funcall +hermite-blend+ s) d1)
		 (* (funcall +hermite-blend+ (- 1 s)) d2)))))))

;;; New version of the bilinear-new sweep (still doesn't work)
(defmethod compute-distance ((type (eql 'two-linear)) points segments p dir)
  (let ((s (first (bilinear-parameterization segments p))))
    (if (eq dir 's)
        s
        (or (handle-point-on-sides segments p)
            (dlet* (((p-1 p0 p1 p2) (segments-prev points segments))
                    ((p1 p2 p3 p4) (segments-next points segments))
                    (a1 p1)
                    (a2 p0)
                    (a3 (affine-combine p0 1/2 p-1))
                    (a4 (affine-combine p1 1/2 p2))
                    (b1 p2)
                    (b2 p3)
                    (b3 (affine-combine p3 1/2 p4))
                    (b4 (affine-combine p1 1/2 p2))
                    (hs (funcall +hermite-blend+ s))
                    (1-hs (- 1 hs))
                    (((a1x a1y) (a2x a2y) (a3x a3y) (a4x a4y)
                      (b1x b1y) (b2x b2y) (b3x b3y) (b4x b4y) (x y))
                     (list a1 a2 a3 a4 b1 b2 b3 b4 p))
                    (X11 (* hs (+ (* (- a2x a1x) (- 1 s s)) (* (- a3x a4x) 2 s))))
                    (X12 (* 1-hs (+ (* (- b2x b1x) (+ s s -1)) (* (- b3x b4x) (- 2 s s)))))
                    (Y1 (+ (* hs (+ (* a1x (- 1 s s)) (* a4x 2 s)))
                           (* 1-hs (+ (* b1x (+ s s -1)) (* b4x (- 2 s s))))
                           (* -1 x)))
                    (X21 (* hs (+ (* (- a2y a1y) (- 1 s s)) (* (- a3y a4y) 2 s))))
                    (X22 (* 1-hs (+ (* (- b2y b1y) (+ s s -1)) (* (- b3y b4y) (- 2 s s)))))
                    (Y2 (+ (* hs (+ (* a1y (- 1 s s)) (* a4y 2 s)))
                           (* 1-hs (+ (* b1y (+ s s -1)) (* b4y (- 2 s s))))
                           (* -1 y)))
                    ;; ((d1 d2) (solve-linear-two-variable X11 X12 Y1 X21 X22 Y2))
                    (matrix (make-array '(2 2) :initial-contents `((,X11 ,X12) (,X21 ,X22))))
                    (vector (vector (- Y1) (- Y2)))
                    ((d1 d2) (coerce (lu-solver:solve matrix vector) 'list)))
              (+ (* hs d1) (* 1-hs d2)))))))

(defun tomification-points (segments p)
  "Idea: Find a constant (y in [0,1]) such that P is on the line (segment)
defined by points on the adjacent sides chosen using linear intepolation (by y).
Another constant (x in [0,1]) is the proportion of P on that line.
Then we return return the two points at x/2 and (x+1)/2 proportion on the line.
kutykurutty This idea seems to be flawed:
the d parameter lines do not start in the adjacent sides' sweep line direction."
  (let* ((p0 (first segments))
	 (p1 (second segments))
	 (p2 (third segments))
	 (p3 (fourth segments)))
    (destructuring-bind (x y) (bilinear-parameterization segments p)
      (let ((left (v+ p1 (v* (v- p0 p1) y)))
	    (right (v+ p2 (v* (v- p3 p2) y))))
	(list (affine-combine left (/ x 2) right)
	      (affine-combine left (/ (1+ x) 2) right))))))

(defmacro deftomified-distance (distance blend-fn)
  "Warning: parameters are evaluated multiple times."
  `(defmethod compute-distance ((type (eql ',(intern (format nil "~:@(~a~)-TOMI" distance))))
				points segments p dir)
     (let ((si (compute-distance ',distance points segments p 's)))
       (if (eq dir 's)
	   si
	   (destructuring-bind (p1 p2) (tomification-points segments p)
	     (let ((si-1 (compute-distance ',distance points
					   (segments-prev points segments)
					   p1 's))
		   (si+1 (compute-distance ',distance points
					   (segments-next points segments)
					   p2 's)))
	       (+ (* (- 1.0d0 si-1) (funcall ,blend-fn si))
		  (* si+1 (funcall ,blend-fn (- 1.0d0 si))))))))))

(deftomified-distance radial +distance-blend+)
(deftomified-distance perpendicular +distance-blend+)
(deftomified-distance barycentric +distance-blend+)
(deftomified-distance chord-based +distance-blend+)
(deftomified-distance line-sweep +distance-blend+)

(defun blend3 (x a b c)
  "Blends between three values, giving A for 0, B for 0.5, C for 1."
  (+ (* x x (+ (* 2 a) (* -4 b) (* 2 c)))
     (* x (+ (* -3 a) (* 4 b) (- c)))
     a))

(defun second-degree-solver (a b c &key min max)
  "TODO: this starts to be incomprehensible..."
  (if (< (abs a) *epsilon*)
      (- (/ c b))
      (let ((discr (- (* b b) (* 4 a c))))
	(cond ((< (abs discr) *epsilon*)
	       (/ (- b) 2 a))
	      ((< discr 0) 0)
	      (t (let* ((discr (sqrt discr))
			(u1 (/ (+ (- b) discr) (* 2 a)))
			(u2 (/ (- (- b) discr) (* 2 a)))
			(u1m (if min (max u1 min) u1))
			(u1mm (if max (min u1m max) u1m))
			(u2m (if min (max u2 min) u2))
			(u2mm (if max (min u2m max) u2m)))
		   (cond ((and min max)
			  (if (< (abs (- u1 u1mm)) (abs (- u2 u2mm)))
			      (values u1mm u2mm)
			      (values u2mm u1mm)))
			 (min
			  (cond ((or (< (abs (- u1 min)) *epsilon*)
				     (< (abs (- u2 min)) *epsilon*))
				 (values min (max u1mm u2mm)))
				((< (abs (- u1 u1mm)) (abs (- u2 u2mm)))
				 (values u1mm u2mm))
				(t (values u2mm u1mm))))
			 (max
			  (cond ((or (< (abs (- u1 max)) *epsilon*)
				     (< (abs (- u2 max)) *epsilon*))
				 (values max (min u1mm u2mm)))
				((< (abs (- u1 u1mm)) (abs (- u2 u2mm)))
				 (values u1mm u2mm))
				(t (values u2mm u1mm))))
			 (t (values u1 u2)))))))))

(defparameter *centralized-line-sweep* nil)
(defmethod compute-distance ((type (eql 'line-sweep)) points segments p dir)
  "BUG: does not work if the base segment is parallel to the Y axis."
  (let* ((c (central-point points (lines-from-points points) t))
	 (p0 (first segments))
	 (p1 (second segments))
	 (p2 (third segments))
	 (p3 (fourth segments)) 
	 (base-x (vnormalize (v- p2 p1)))
	 (base-y (list (- (second base-x)) (first base-x)))
	 (center (in-system base-x base-y (v- c p1)))
	 (p (in-system base-x base-y (v- p p1)))
	 (length (point-distance p1 p2))
	 (w0 (in-system base-x base-y (v- p0 p1)))
	 (w2 (in-system base-x base-y (v- p3 p2)))
	 (w1 (center-line w0 w2 length center))
	 (s (line-sweep w0 w1 w2 length p)))
    (if (eq dir 'd)
	(case *centralized-line-sweep*
	  ((t)
	   (/ (point-distance p (list (* s length) 0))
	      (blend3 s (vlength w0)
		      (* 2 (point-distance center (list (/ length 2) 0)))
		      (vlength w2))))
	  ((nil)
	   (/ (point-distance p (list (* s length) 0))
	      (iter (for q1 in points)
		    (maximize (iter (for q2 in points)
				    (maximize (point-distance q1 q2)))))))
          ((tomi)
           (/ (second p) (+ (* (second w0) (- 1 s)) (* (second w2) s))))
          ((tomi-centralized)
           (let ((d (/ (second p)
                       (+ (* (second w0) (- 1 s)) (* (second w2) s))))
                 (dc (/ (* 2 (second center)) (+ (second w0) (second w2)))))
             (* d (+ (* (- 1 s) (- 1 s))
                     (* (/ (- 1 dc) dc) 2 (- 1 s) s)
                     (* s s)))))
	  (otherwise
	   (let* ((a (- (* (second w2) (first w0)) (* (second w0) (first w2))))
		  (b (- (+ (* (second p) (first w2)) (* (first p) (second w0)))
			(+ (* (first p) (second w2)) (* (second p) (first w0))
			   (* length (second w0)))))
		  (l (second-degree-solver a b (* (second p) length) :min 0.0d0)))
	     (* l (blend3 s 1 (/ *centralized-line-sweep*) 1)))))
	s)))

(defun central-point (points lines weightedp)
  (flet ((slength (line) (apply #'point-distance line)))
    (if weightedp
	(v* (reduce #'v+ (mapcar (lambda (p l1 l2)
				   (v* p (+ (slength l1) (slength l2))))
				 points lines (append (rest lines) lines)))
	    (/ (* 2 (reduce #'+ (mapcar #'slength lines)))))
	(v* (reduce #'v+ points) (/ (length lines))))))

(defun write-color (stream type &optional (1-alpha 0))
  (let ((alpha (- 1.0d0 1-alpha)))
    (flet ((aliasing (x) (floor (+ (* alpha x) (* 1-alpha 255)))))
      (format stream "~{~d~^ ~}" (mapcar #'aliasing (cdr (assoc type *colors*)))))))

(defun distance-function-test (points distance-type line-type filename)
  (let* ((points (mapcar (lambda (p)
			   (list (/ (+ *width* (* *width* (first p))) 2)
				 (/ (+ *height* (* *height* (second p))) 2)))
			 points))
	 (lines (lines-from-points points))
	 (center (central-point points lines t)))
    (with-open-file (s filename :direction :output :if-exists :supersede)
      (format s "P3~%~d ~d~%255~%" *width* *height*)
      (labels ((parameter (lst type x y)
		 (compute-distance distance-type points lst (list x y) type))
	       (outsidep (x y)
		 (some (lambda (line)
			 (< (* (point-line-distance (list x y) line t)
			       (point-line-distance center line t))
			     0))
			lines))
	       (better-points (lst type x y base)
		 (iter (for i from -1 to 1)
		       (sum (iter (for j from -1 to 1)
				  (for current =
				       (mod (parameter lst type (+ x i) (+ y j))
					    *density*))
				  (count (< current base))))))
	       (on-parameter-line (lst type x y)
		 (let ((current (mod (parameter lst type x y) *density*)))
		   (and (< current *line-width*)
			(<= (better-points lst type x y current) 2)
			(/ current *line-width*)))))
	(iter (for y from 0 below *height*)
	      (iter (for x from 0 below *width*)
		    (unless (zerop x)
		      (princ #\Space s))
		    (acond ((or (some (lambda (l)
					(and (on-segment-p (first l) (second l) x y)
					     (/ (point-line-distance (list x y) l)
						*tolerance*)))
				      lines)
				(let ((center-error (point-distance (list x y) center)))
				  (and (< center-error *point-size*)
				       (/ center-error *point-size*))))
			    (write-color s 'on-line it))
			   ((outsidep x y)
			    (declare (ignore it))
			    (write-color s 'outside))
			   ((on-parameter-line (subseq points 0 4)
					       (first line-type) x y) 
			    (if (eq (first line-type) 's)
				(write-color s 'si it)
				(write-color s 'di it)))
			   ((eq (first line-type) (second line-type))
			    (if (on-parameter-line (subseq points 1 5)
						   (second line-type) x y)
				(if (eq (second line-type) 's)
				    (write-color s 'si-1 it)
				    (write-color s 'di-1 it))
				(write-color s 'nothing)))
			   ((on-parameter-line (subseq points 0 4)
					       (second line-type) x y)
			    (if (eq (second line-type) 's)
				(write-color s 'si it)
				(write-color s 'di it)))
			   (t
			    (declare (ignore it))
			    (write-color s 'nothing))))
	      (terpri s))))))

(defun distance-function-complete-set (points directory)
  (iter (for type in '(perpendicular barycentric chord-based radial line-sweep))
	(iter (for lines in '((s d) (s s) (d d)))
	      (for name = (format nil "~(~a~)-~{~(~a~)~}.ppm" type lines))
	      (for filename = (make-pathname :directory directory :name name))
	      (distance-function-test points type lines filename))))

;; (kato-test '(250 240) '(390 240) "/tmp/kato.pgm")

#+nil
(let ((*density* 5.0d0)
      (*line-width* 1.0d0))
  (kato-test '(10 240) '(630 240) "/tmp/kato.pgm"))

#+nil
(let ((*density* 0.1d0)
      (*line-width* 0.01d0))
  (kato-test-2 '(180 120) '(250 240) '(390 240) '(460 120) "/tmp/kato.pgm"))

#+nil
(let ((*density* 0.1d0)
      (*line-width* 0.01d0))
  (kato-test-2 '(160 100) '(220 240) '(420 240) '(460 270) "/tmp/kato.pgm"))

#+nil
(let ((*density* 0.03d0)
      (*line-width* 0.01d0))
  (kato-test-2 '(190 100) '(220 240) '(420 240) '(500 180) "/tmp/kato.pgm"))

#+nil
(let ((*density* 0.025d0)
      (*line-width* 0.01d0))
  (central-line-sweep '(190 100) '(220 240) '(420 240) '(500 180) '(380 80)
		      "/tmp/sweep.pgm"))

#+nil
(let ((*density* 0.03d0)
      (*line-width* 0.01d0))
  (radial-test '(190 100) '(220 240) '(420 240) '(500 180) "/tmp/radial.pgm"))

#+nil
(let ((*width* 640) (*height* 480) 
      (*density* 0.05d0)
      (*line-width* 0.01d0)
      (*point-size* 3.0d0)
      (*tolerance* 1.0d0))
  (distance-function-test (points-from-angles '(40 20 60 100 80)) 'chord-based '(s d)
			  "/tmp/distance.ppm"))

#+nil
(defun trace-parameter-buggy (points i distance-type type parameter resolution)
  (let ((lines (lines-from-points points)))
    (labels ((query (p) (- (elt (compute-parameter distance-type type points p t) i) parameter))
	     (between (p1 p2)
	       (when p2
		 (affine-combine (rest p1) (/ (first p2) (- (first p2) (first p1))) (rest p2))))
	     (get-start (line)
	       (let ((k (/ (point-distance (first line) (second line)) resolution)))
		 (iter (repeat (1+ (floor k)))
		       (with d = (v* (v- (second line) (first line)) (/ k)))
		       (for p first (first line) then (v+ p d))
		       (collect (cons (abs (query p)) p) into tests)
		       (finally (return (rest (first (sort tests #'< :key #'first))))))))
	     (best-few (actual value)
	       (iter (for xi from -1 to 1)
		     (for x = (+ (first actual) (* xi resolution)))
		     (appending
		      (iter (for yi from -1 to 1)
			    (unless (= xi yi 0)
			      (for y = (+ (second actual) (* yi resolution)))
			      (collect (list (query (list x y)) x y))))
		      into lst)
		     (finally (return (sort (mapcar (lambda (x)
						      (cons (abs (first x)) (rest x)))
						    (remove-if (lambda (x)
								 (> (* (first x) value) 0))
							       lst))
					    #'< :key #'first)))))
	     (best-one (prev actual)
	       (let ((value (query actual)))
		 (between
		  (cons value actual)
		  (first (remove-if (lambda (point)
				      (let ((p (rest point)))
					(or (not (insidep lines p))
					    (and prev
						 (> (scalar-product (v- prev actual) (v- p actual))
						    0)))))
				    (best-few actual value)))))))
      (let ((start (get-start (elt lines (case type
					   (s i)
					   (d1 (mod (1- i) (length lines)))
					   (d2 (mod (1+ i) (length lines))))))))
	(cons start
	      (iter (for pprev first nil then prev)
		    (for prev first start then next)
		    (for next = (best-one pprev prev))
		    (while next)
		    (collect next)))))))

(defun trace-parameter (points i distance-type type parameter resolution)
  (let ((lines (lines-from-points points)))
    (labels ((query (p)
	       (abs (- (elt (compute-parameter distance-type type points p t) i) parameter)))
	     ;; (between (p1 v1 p2 v2) (affine-combine p1 (/ v2 (- v2 v1)) p2))
	     (get-start (line)
	       (let ((k (/ (point-distance (first line) (second line)) resolution)))
		 (iter (repeat (1+ (floor k)))
		       (with d = (v* (v- (second line) (first line)) (/ k)))
		       (for p first (first line) then (v+ p d))
		       (collect (cons (query p) p) into tests)
		       (finally (return (first (sort tests #'< :key #'first)))))))
	     (get-fuzzy-start (index)
	       (iter (for i from 0 below (length lines))
		     (for line in lines)
		     (unless (= i index)
		       (for (value . param) = (get-start line))
		       (finding param minimizing value))))
	     (best-three (actual)
	       (iter (for xi from -1 to 1)
		     (for x = (+ (first actual) (* xi resolution)))
		     (appending
		      (iter (for yi from -1 to 1)
			    (unless (= xi yi 0)
			      (for y = (+ (second actual) (* yi resolution)))
			      (collect (list (query (list x y)) x y))))
		      into lst)
		     (finally (return (subseq (mapcar #'rest (sort lst #'< :key #'first)) 0 3)))))
	     (best-one (prev actual)
	       (first (remove-if (lambda (p)
				   (or (not (insidep lines p))
				       (and prev
					    (> (scalar-product (v- prev actual) (v- p actual)) 0))))
				 (best-three actual)))))
      (let ((start (if (eq type 's) (rest (get-start (elt lines i))) (get-fuzzy-start i))))
	(cons start
	      (iter (for pprev first nil then prev)
		    (for prev first start then next)
		    (for next = (best-one pprev prev))
		    (while next)
		    (collect next)))))))

(defun trace-biquadratic (distance-type points i type parameter resolution)
  (let* ((n (length points))
	 (segments (list (elt points (mod (- i 2) n))
			 (elt points (mod (1- i) n))
			 (elt points (mod i n))
			 (elt points (mod (1+ i) n))))
	 (net (if (eq distance-type 'biquadratic)
		  (biquadratic-net points segments)
		  (biquadratic-corner-net points segments))))
    (iter (for x from 0 to 1 by resolution)
	  (collect (biquadratic-point net
				      (if (eq type 's)
					  (list parameter x)
					  (list x parameter)))))))

(defun vectorized-distance-function-test (points line-types filename &key (resolution 0.1d0)
					  (density 4) (distance-type 'perpendicular)
					  (color t))
  "LINE-TYPES is a list of symbols, each of which can be S, D or SD."
  (flet ((map-point (p)
	   (list (* (+ (first p) 1.0d0) 200)
		 (* (+ (second p) 1.0d0) 200))))
    (let* ((n (length points)) 
	   (lines (lines-from-points points))
	   (colors (or (and color (generate-colors n))
		       (iter (repeat n) (collect '(0 0 0)))))
	   (center (central-point points lines t)))
      (with-open-file (s filename :direction :output :if-exists :supersede)
	(format s "%!PS~%")
	(format s "~{~f ~}3 0 360 arc fill~%" (map-point center))
	(iter (for i from 0 below n)
	      (for color in colors)
	      (for line in lines)
	      (for line-type in line-types)
	      (format s "% Segment: ~a~%" i)
	      (format s "~{~d ~}setrgbcolor~%" color)
	      (format s "2 setlinewidth~%~
                         newpath~%~
                         ~{~f ~}moveto~%~
                         ~{~f ~}lineto~%~
                         stroke~%~
                         1 setlinewidth~%"
		      (map-point (first line))
		      (map-point (second line)))
	      (iter (for type in (case line-type (s '(s)) (d '(d)) (sd '(s d))))
		    (format s "% Type: ~a~%" type)
		    (iter (with d = (/ density))
			  (for parameter from 0 to 1 by d)
			  (format s "% Parameter: ~a~%" parameter)
			  (for trace =
			       (if (member distance-type '(biquadratic biquadratic-corner))
				   (trace-biquadratic distance-type points i type parameter resolution)
				   (trace-parameter points i distance-type type
						    parameter resolution)))
			  (format s "newpath~%")
			  (format s "~{~f ~}moveto~%~
                                     ~{~{~f ~}lineto~%~}"
				  (map-point (first trace))
				  (mapcar #'map-point (rest trace)))
			  (format s "stroke~%"))))
	(format s "showpage~%")))))

#+nil
(vectorized-distance-function-test
 (points-from-angles '(40 20 60 100 80)) '(sd nil nil nil sd) "/tmp/params.ps"
 :resolution 0.1d0 :density 4 :distance-type 'chord-based)

(defun biquadratic-net (points segments)
  "Uses Bezier curves to determine dangling corners."
  (let ((net (make-array '(3 3)))
	(n (length points)))
    (setf (aref net 0 0) (second segments)
	  (aref net 0 1) (affine-combine (second segments) 1/2 (third segments))
	  (aref net 0 2) (third segments)
	  (aref net 1 0) (affine-combine (first segments) 1/2 (second segments))
	  (aref net 1 1) (central-point points (lines-from-points points) t)
	  (aref net 1 2) (affine-combine (third segments) 1/2 (fourth segments)))
    (if (= n 3)
	(setf (aref net 2 0) (first segments)
	      (aref net 2 1) (first segments)
	      (aref net 2 2) (first segments))
	(let* ((i (position (fourth segments) points :test #'equal))
	       (curve (subseq (append points points) i (+ i n -2))))
	  (setf (aref net 2 0) (first segments)
		(aref net 2 1) (bezier curve 1/2)
		(aref net 2 2) (fourth segments))))
    net))

#+nil
(defun biquadratic-net (points segments)
  "Uses opposing corners as dangling corners."
  (let ((net (make-array '(3 3)))
	(n (length points)))
    (setf (aref net 0 0) (second segments)
	  (aref net 0 1) (affine-combine (second segments) 1/2 (third segments))
	  (aref net 0 2) (third segments)
	  (aref net 1 0) (affine-combine (first segments) 1/2 (second segments))
	  (aref net 1 1) (central-point points (lines-from-points points) t)
	  (aref net 1 2) (affine-combine (third segments) 1/2 (fourth segments)))
    (if (= n 3)
	(setf (aref net 2 0) (first segments)
	      (aref net 2 1) (first segments)
	      (aref net 2 2) (first segments))
	(let ((i (position (second segments) points :test #'equal))
	      (k (ceiling n 2)))
	  (setf (aref net 2 0) (first segments)
		(aref net 2 1) (affine-combine (elt points (mod (- i k -1) n))
					       1/2
					       (elt points (mod (+ i k) n)))
		(aref net 2 2) (fourth segments))))
    net))

(defun biquadratic-corner-net (points segments)
  "Uses Bezier curves to determine dangling corners."
  (let ((net (make-array '(3 3)))
	(n (length points)))
    (setf 
	  (aref net 0 0) (second segments)
	  (aref net 0 1) (affine-combine (second segments) 1/2 (third segments))
	  (aref net 0 2) (third segments)
	  (aref net 1 0) (affine-combine (first segments) 1/2 (second segments))
	  (aref net 1 1) (central-point points (lines-from-points points) t)
	  (aref net 2 0) (first segments))
    (if (= n 3)
	(setf (aref net 1 2) (third segments)
	      (aref net 2 1) (first segments)
	      (aref net 2 2) (affine-combine (third segments) 1/2 (fourth segments)))
	(let* ((i (position (third segments) points :test #'equal))
	       (k (ceiling n 2))
	       (curve1 (subseq (append points points) i (+ i n -2)))
	       (curve2 (subseq (append points points) (1+ i) (+ i n -1))))
	  (setf (aref net 1 2) (bezier curve1 1/2)
		(aref net 2 1) (bezier curve2 1/2)
		(aref net 2 2) (affine-combine (elt points (mod (- i 1 k) n))
					       1/2
					       (elt points (mod (+ i -1 k) n))))))
    net))

#+nil
(defun biquadratic-corner-net (points segments)
  "Uses opposing corners as dangling corners."
  (let ((net (make-array '(3 3)))
	(n (length points)))
    (setf (aref net 0 0) (second segments)
	  (aref net 0 1) (affine-combine (second segments) 1/2 (third segments))
	  (aref net 0 2) (third segments)
	  (aref net 1 0) (affine-combine (first segments) 1/2 (second segments))
	  (aref net 1 1) (central-point points (lines-from-points points) t)
	  (aref net 2 0) (first segments))
    (if (= n 3)
	(setf (aref net 1 2) (third segments)
	      (aref net 2 1) (first segments)
	      (aref net 2 2) (affine-combine (third segments) 1/2 (fourth segments)))
	(let* ((i (position (second segments) points :test #'equal))
	       (k (ceiling n 2)))
	  (setf (aref net 1 2) (affine-combine (elt points (mod (- i k) n))
					       1/2
					       (elt points (mod (+ i k -1) n)))
		(aref net 2 1) (affine-combine (elt points (mod (- i k -1) n))
					       1/2
					       (elt points (mod (+ i k) n)))
		(aref net 2 2) (affine-combine (elt points (mod (- i k) n))
					       1/2
					       (elt points (mod (+ i k) n))))))
    net))

(defun write-biquadratic-net (net filename)
  (labels ((map-point (p)
	     (list (* (+ (first p) 1.0d0) 200)
		   (* (+ (second p) 1.0d0) 200)))
	   (pp (i j) (map-point (aref net i j))))
    (with-open-file (s filename :direction :output :if-exists :supersede)
      (format s "%!PS~%")
      (dotimes (i 3)
	(dotimes (j 2)
	  (format s "newpath~%~{~f ~}moveto~%~{~f ~}lineto~%stroke~%"
		  (pp i j) (pp i (1+ j)))
	  (format s "newpath~%~{~f ~}moveto~%~{~f ~}lineto~%stroke~%"
		  (pp j i) (pp (1+ j) i))))
      (format s "showpage~%"))))

(defun biquadratic-point (net uv &optional derivative)
  (let ((u (first uv))
	(v (second uv)))
    (flet ((sqr (x) (* x x)))
      (let (u0 u1 u2 v0 v1 v2)
	(ecase derivative
	  ((nil)
	   (setf u0 (sqr (- 1 u)) u1 (* 2 u (- 1 u)) u2 (sqr u)
		 v0 (sqr (- 1 v)) v1 (* 2 v (- 1 v)) v2 (sqr v)))
	  (u
	   (setf u0 (* 2 (- u 1)) u1 (* 2 (- 1 (* 2 u))) u2 (* 2 u)
		 v0 (sqr (- 1 v)) v1 (* 2 v (- 1 v)) v2 (sqr v)))
	  (v
	   (setf u0 (sqr (- 1 u)) u1 (* 2 u (- 1 u)) u2 (sqr u)
		 v0 (* 2 (- v 1)) v1 (* 2 (- 1 (* 2 v))) v2 (* 2 v)))
	  (u2
	   (setf u0 2 u1 -4 u2 2
		 v0 (sqr (- 1 v)) v1 (* 2 v (- 1 v)) v2 (sqr v)))
	  (uv
	   (setf u0 (* 2 (- u 1)) u1 (* 2 (- 1 (* 2 u))) u2 (* 2 u)
		 v0 (* 2 (- v 1)) v1 (* 2 (- 1 (* 2 v))) v2 (* 2 v)))
	  (v2
	   (setf u0 (sqr (- 1 u)) u1 (* 2 u (- 1 u)) u2 (sqr u)
		 v0 2 v1 -4 v2 2)))
	(v+ (v* (v+ (v* (aref net 0 0) u0)
		    (v* (aref net 0 1) u1)
		    (v* (aref net 0 2) u2))
		v0)
	    (v* (v+ (v* (aref net 1 0) u0)
		    (v* (aref net 1 1) u1)
		    (v* (aref net 1 2) u2))
		v1)
	    (v* (v+ (v* (aref net 2 0) u0)
		    (v* (aref net 2 1) u1)
		    (v* (aref net 2 2) u2))
		v2))))))

;;; Newton-Raphson algorithm
;;; adapted from BSS-PROJECT-POINT & friends (projection.lisp)

(defun bq-projection-starting-value (net point res)
  (iter (with lower = '(0.0d0 0.0d0))
	(with upper = '(1.0d0 1.0d0))
	(with length = (mapcar #'- upper lower))
	(for i from 0 below (first res))
	(for u = (+ (first lower) (/ (* i (first length)) (1- (first res)))))
	(for (min v) =
	     (iter (for j from 0 below (second res))
		   (for v = (+ (second lower) (/ (* j (second length))
						 (1- (second res)))))
		   (for distance = (vlength
				    (v- point
					(biquadratic-point net (list u v)))))
		   (finding (list distance v) minimizing distance)))
	(finding (list u v) minimizing min)))

(defun bq-projection-delta (net uv r)
  (let* ((du (biquadratic-point net uv 'u))
	 (dv (biquadratic-point net uv 'v))
	 (du2 (biquadratic-point net uv 'u2))
	 (duv (biquadratic-point net uv 'uv))
	 (dv2 (biquadratic-point net uv 'v2))
	 (k (make-array '(2 1) :initial-contents
			`((,(- (scalar-product r du)))
			  (,(- (scalar-product r dv))))))
	 (J (make-array
	     '(2 2) :initial-contents
	     `((,(+ (scalar-product du du) (scalar-product r du2))
		 ,(+ (scalar-product du dv) (scalar-product r duv)))
	       (,(+ (scalar-product du dv) (scalar-product r duv))
		 ,(+ (scalar-product dv dv) (scalar-product r dv2))))))
	 (delta (matrix:multiplication (matrix:inverse-2x2 J) k)))
    (list (aref delta 0 0) (aref delta 1 0))))

(defun bq-halving-search (net point iterations &optional (distance-tolerance 0))
  (labels ((rec (lower upper iter)
	     (let* ((mid (affine-combine lower 0.5d0 upper))
		    (p (biquadratic-point net mid))
		    (distance (point-distance point p)))
	       (if (or (= iter 0) (< distance distance-tolerance))
		   (values mid distance)
		   (let ((d (v- point p))
			 (pu (biquadratic-point net mid 'u))
			 (pv (biquadratic-point net mid 'v))
			 (new-lower lower)
			 (new-upper upper))
		     (if (< (scalar-product d pu) 0)
			 (setf new-upper (list (first mid) (second new-upper)))
			 (setf new-lower (list (first mid) (second new-lower))))
		     (if (< (scalar-product d pv) 0)
			 (setf new-upper (list (first new-upper) (second mid)))
			 (setf new-lower (list (first new-lower) (second mid))))
		     (rec new-lower new-upper (1- iter)))))))
    (rec '(0 0) '(1 1) iterations)))

(defun bq-project-point (net point iterations &optional
			  (distance-tolerance 0.0) (cosine-tolerance 0.0))
  "Returns the parameters of the biquadratic defined by NET closest to POINT."
  (let ((uv0 (bq-halving-search net point iterations (* distance-tolerance 10)))
	(lower '(0.0d0 0.0d0))
	(upper '(1.0d0 2.0d0)))
    (iter (repeat iterations)
	  (for last first nil then uv)
	  (for uv first uv0 then
	       (mapcar (lambda (x next low upp) (min (max (+ x next) low) upp))
		       uv (bq-projection-delta net uv deviation)
		       lower upper))
	  (for p = (biquadratic-point net uv))
	  (for du = (biquadratic-point net uv 'u))
	  (for dv = (biquadratic-point net uv 'v))
	  (for deviation = (v- p point))
	  (when (or (<= (vlength deviation) distance-tolerance)
		    (and (<= (/ (abs (scalar-product du deviation))
				(* (vlength du) (vlength deviation)))
			     cosine-tolerance)
			 (<= (/ (abs (scalar-product dv deviation))
				(* (vlength dv) (vlength deviation)))
			     cosine-tolerance))
		    (and last
			 (<= (+ (vlength (v* du (- (first uv) (first last))))
				(vlength (v* dv (- (second uv) (second last)))))
			     distance-tolerance)))
	    (leave (values uv (vlength deviation))))
	  (finally (return (values uv (vlength deviation)))))))

(defun gsll-minimize-2d (fn start iterations deviation)
  (let ((obj (gsll:make-multi-dimensional-root-solver-fdf
	      gsll:+gnewton-mfdfsolver+
	      (list (lambda (u v)
		      (let ((f (funcall fn (list u v))))
			(values (first f) (second f))))
		    (lambda (u v)
		      (let ((fu (funcall fn (list u v) 'u))
			    (fv (funcall fn (list u v) 'v)))
			(values (first fu) (first fv)
				(second fu) (second fv))))
		    (lambda (u v)
		      (let ((f (funcall fn (list u v)))
			    (fu (funcall fn (list u v) 'u))
			    (fv (funcall fn (list u v) 'v)))
			(values (first f) (second f)
				(first fu) (first fv)
				(second fu) (second fv)))))
	      (grid:make-foreign-array 'double-float :dimensions 2
				       :initial-contents start))))
    (iter (repeat iterations)
	  (gsll:iterate obj)
	  (until (gsll:multiroot-test-residual obj deviation))
	  (finally (let ((result (gsll:solution obj)))
		     (return (list (grid:gref result 0) (grid:gref result 1))))))))

(defun bq-project-point-gsll (net point iterations deviation)
  (flet ((fn (uv &optional deriv)
	   (if deriv
	       (biquadratic-point net uv deriv)
	       (v- (biquadratic-point net uv) point))))
    (gsll-minimize-2d #'fn '(0.5d0 0.5d0) iterations deviation)))

(defmethod compute-distance ((type (eql 'biquadratic)) points segments p dir)
  (let ((sd (bq-project-point-gsll (biquadratic-net points segments) p 20 1.0d-8)))
    (if (eq dir 's)
	(first sd)
	(second sd))))

(defmethod compute-distance ((type (eql 'biquadratic-corner)) points segments p dir)
  (let ((sd (bq-project-point-gsll (biquadratic-corner-net points segments) p 20 1.0d-8)))
    (if (eq dir 's)
	(first sd)
	(second sd))))

(defparameter *wachspressp* t)

(defun mean-value (points values p)
  (let ((lengths (mapcar (lambda (x) (point-distance p x)) points))
        (n (length points)))
    (labels ((heron% (a b c)
               (let ((s (/ (+ a b c) 2)))
                 (sqrt (* s (- s a) (- s b) (- s c)))))
             (heron (a b c)
               (let ((a (heron% a b c)))
                 (if (complexp a) 0 a)))
	     (on-same-side-p (line p q)
	       (let* ((dir (vnormalize (v- (second line) (first line))))
		      (n (list (- (second dir)) (first dir))))
		 (> (* (scalar-product (v- p (first line)) n)
		       (scalar-product (v- q (first line)) n))
		    0)))
             (inc (i) (mod (1+ i) n))
             (dec (i) (mod (1- i) n))
             (area-a (i)
               (heron (elt lengths i)
                      (elt lengths (inc i))
                      (point-distance (elt points i)
                                      (elt points (inc i)))))
             (area-b (i)
               (* (heron (elt lengths (dec i))
			 (elt lengths (inc i))
			 (point-distance (elt points (dec i))
					 (elt points (inc i))))
		  (if (on-same-side-p (list (elt points (dec i))
					    (elt points (inc i)))
				      (elt points i) p)
		      -1 1))))
      (let* ((linear '())
             (w (iter (for i from 0 below n)
                      (for Ai = (area-a i))
                      (for Ai-1 = (area-a (dec i)))
                      (for Bi = (area-b i))
                      (for ri-1 = (elt lengths (dec i)))
                      (for ri = (elt lengths i))
                      (for ri+1 = (elt lengths (inc i)))
                      (cond ((< Ai-1 *epsilon*)
                             (push i linear)
                             (collect (/ (elt lengths (dec i))
                                         (point-distance (elt points (dec i))
                                                         (elt points i)))))
                            ((< Ai *epsilon*)
                             (push i linear)
                             (collect (/ (elt lengths (inc i))
                                         (point-distance (elt points (inc i))
                                                         (elt points i)))))
                            (t (collect (/ (+ (* ri-1 Ai) (* -1 ri Bi) (* ri+1 Ai-1))
                                           (* Ai-1 Ai)))))))
             (wsum (reduce #'+ w)))
        (if (null linear)
            (iter (for i from 0 below n)
                  (sum (/ (* (elt values i) (elt w i)) wsum)))
            (iter (for i in linear)
                  (sum (* (elt values i) (elt w i)))))))))

(defun wachspress (points values p)
  (let ((lengths (mapcar (lambda (x) (point-distance p x)) points))
        (n (length points)))
    (labels ((heron% (a b c)
               (let ((s (/ (+ a b c) 2)))
                 (sqrt (* s (- s a) (- s b) (- s c)))))
             (heron (a b c)
               (let ((a (heron% a b c)))
                 (if (complexp a) 0 a)))
	     (on-same-side-p (line p q)
	       (let* ((dir (vnormalize (v- (second line) (first line))))
		      (n (list (- (second dir)) (first dir))))
		 (> (* (scalar-product (v- p (first line)) n)
		       (scalar-product (v- q (first line)) n))
		    0)))
             (inc (i) (mod (1+ i) n))
             (dec (i) (mod (1- i) n))
             (area-a (i)
               (heron (elt lengths i)
                      (elt lengths (inc i))
                      (point-distance (elt points i)
                                      (elt points (inc i)))))
             (area-c (i)
               (heron (point-distance (elt points (dec i))
				      (elt points i))
		      (point-distance (elt points (dec i))
				      (elt points (inc i)))
		      (point-distance (elt points i)
				      (elt points (inc i))))))
      (let* ((linear '())
             (w (iter (for i from 0 below n)
                      (for Ai = (area-a i))
                      (for Ai-1 = (area-a (dec i)))
                      (for Ci = (area-c i))
                      (cond ((< Ai-1 *epsilon*)
                             (push i linear)
                             (collect (/ (elt lengths (dec i))
                                         (point-distance (elt points (dec i))
                                                         (elt points i)))))
                            ((< Ai *epsilon*)
                             (push i linear)
                             (collect (/ (elt lengths (inc i))
                                         (point-distance (elt points (inc i))
                                                         (elt points i)))))
                            (t (collect (/ Ci (* Ai-1 Ai)))))))
             (wsum (reduce #'+ w)))
        (if (null linear)
            (iter (for i from 0 below n)
                  (sum (/ (* (elt values i) (elt w i)) wsum)))
            (iter (for i in linear)
                  (sum (* (elt values i) (elt w i)))))))))

(defun mean-blend (points segments p)
  (let ((values (mapcar (lambda (x)
                          (if (or (equal x (second segments))
                                  (equal x (third segments)))
                              1
                              0))
                        points)))
    (funcall +hermite-blend+ (- 1 (if *wachspressp*
                                      (wachspress points values p)
                                      (mean-value points values p))))))

(defun mean-distance (points segments p)
  (let ((values (mapcar (lambda (x)
                          (if (or (equal x (second segments))
                                  (equal x (third segments)))
                              0
                              1))
                        points)))
    (if *wachspressp*
	(wachspress points values p)
	(mean-value points values p))))

(defmacro defmean-distance (distance)
  "Warning: parameters are evaluated multiple times."
  `(defmethod compute-distance ((type (eql ',(intern (format nil "MEAN-~:@(~a~)" distance))))
				points segments p dir)
     (if (eq dir 's)
         (compute-distance ',distance points segments p 's)
         (mean-distance points segments p))))

(defmean-distance bilinear)
(defmean-distance line-sweep)

#+nil
(let ((points (points-from-angles '(40 20 60 100 80)))
      (*wachspressp* nil))
  (vectorized-distance-function-test
   points '(nil sd nil nil nil) "/tmp/proba.ps"
   :resolution 0.001d0 :density 6 :distance-type 'mean-line-sweep :color nil))

(defmethod compute-distance ((type (eql 'mean-value)) points segments p dir)
  (if (eq dir 'd)
      (mean-distance points segments p)
      (let ((d-1 (mean-distance points (segments-prev points segments) p))
            (d+1 (mean-distance points (segments-next points segments) p)))
        (/ d-1 (+ d-1 d+1)))))

#+nil
(let ((points (points-from-angles '(40 20 60 100 80)))
      (*wachspressp* nil))
  (vectorized-distance-function-test
   points '(nil sd nil nil nil) "/tmp/proba.ps"
   :resolution 0.001d0 :density 6 :distance-type 'mean-value :color nil))

(defun mean-test (points i filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "P2~%~d ~d~%2~%" *width* *height*)
    (iter (with lines = (lines-from-points points))
          (with segments =
                (iter (for j from 0 below 4)
                      (collect (elt points (mod (+ i j) (length points))))))
          (for y from 0 below *height*)
          (for v = (- (/ (* 2 y) *height*) 1))
          (iter (for x from 0 below *width*)
                (for u = (- (/ (* 2 x) *width*) 1))
                (for p = (list u v))
                (unless (zerop x)
                  (princ #\Space s))
                (for current = (mean-distance points segments p))
                (cond ((not (insidep lines p))
                       (princ 1 s))
                      ((< (mod current 0.1) *line-width*)
                       (princ 0 s))
                      (t (princ 2 s))))
          (terpri s))))

#+nil
(let ((*width* 500)
      (*height* 500)
      (*line-width* 0.005d0)
      (points (points-from-angles '(45 90 45 15 150 15))))
  (mean-test points 5 "/tmp/proba3.pgm"))

(defun mean-test-one (points i filename)
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "P2~%~d ~d~%255~%" *width* *height*)
    (iter (with lines = (lines-from-points points))
          (with values = (iter (for j from 0 below (length points))
                               (collect (if (= i j) 1 0))))
          (for y from 0 below *height*)
          (for v = (- (/ (* 2 y) *height*) 1))
          (iter (for x from 0 below *width*)
                (for u = (- (/ (* 2 x) *width*) 1))
                (for p = (list u v))
                (unless (zerop x)
                  (princ #\Space s))
                (for current = (if *wachspressp*
				   (wachspress points values p)
				   (mean-value points values p)))
                (if (not (insidep lines p))
                    (princ 255 s)
                    (princ (floor (* (- 1 current) 200)) s)))
          (terpri s))))

#+nil
(let ((*width* 500)
      (*height* 500)
      (points (points-from-angles '(40 20 60 100 80))))
  (iter (for i from 0 below 5)
        (mean-test-one points i (format nil "/tmp/proba-~d.pgm" (1+ i)))))

(defun write-color-mean-test (points filename r &key (trim '(0.89d0 0.91d0)))
  (flet ((map-coordinates (x y) (list (/ (- x r) r) (/ (- y r) r))))
    (let* ((wh (1+ (* 2 r)))
	   (n (length points))
	   (lines (lines-from-points points))
	   (colors (generate-colors n)))
      (with-open-file (s filename :direction :output :if-exists :supersede)
        (format s "P3~%~d ~d~%255~%" wh wh)
        (dotimes (x wh)
          (dotimes (y wh)
            (let ((p (map-coordinates x y)))
              (if (insidep lines p)
                  (let ((blends (iter (for i from 0 below n)
                                      (for segments =
                                           (iter (for j from 0 below 4)
                                                 (collect (elt points (mod (+ i j) n)))))
                                      (collect (/ (mean-blend points segments p) 2)))))
                    (if (and trim (some (lambda (x) (< (first trim) x (second trim))) blends))
			(format s "0 0 0~%")
			(format s "~{~d~^ ~}~%"
				(mapcar #'round
					(reduce (lambda (x y) (mapcar #'+ x y))
						(mapcar #'v* colors blends))))))
                  (format s "255 255 255~%")))))))))

#+nil
(let ((points (points-from-angles '(40 20 60 100 80))))
  (write-color-mean-test points "/tmp/proba.ppm" 400 :trim '(0.89d0 0.91d0)))

(defun write-mean-voronoi (points filename r &key (threshold 0.01d0))
  (flet ((map-coordinates (x y) (list (/ (- x r) r) (/ (- y r) r))))
    (let* ((wh (1+ (* 2 r)))
	   (n (length points))
	   (lines (lines-from-points points)))
      (with-open-file (s filename :direction :output :if-exists :supersede)
        (format s "P3~%~d ~d~%255~%" wh wh)
        (dotimes (x wh)
          (dotimes (y wh)
            (let ((p (map-coordinates x y)))
              (if (insidep lines p)
                  (let ((blends (iter (for i from 0 below n)
                                      (for segments =
                                           (iter (for j from 0 below 4)
                                                 (collect (elt points (mod (+ i j) n)))))
                                      (collect (/ (mean-blend points segments p) 2)))))
                    (if (destructuring-bind (a b)
			    (subseq (sort blends #'>) 0 2)
			  (< (- a b) threshold))
			(format s "0 0 0~%")
			(format s "127 127 127~%")))
                  (format s "255 255 255~%")))))))))

#+nil
(let ((points (points-from-angles '(40 20 60 100 80))))
  (write-mean-voronoi points "/tmp/proba.ppm" 400))

(defun write-mean-blends (points on-off filename)
  (let* ((n (length points))
	 (vertices (mapcar (lambda (p)
			     (let ((blends (iter (for i from 0 below n)
                                                 (for segments =
                                                      (iter (for j from 0 below 4)
                                                            (collect (elt points (mod (+ i j) n)))))
                                                 (collect (mean-blend points segments p)))))
			       (cons (iter (for i from 0 below (length on-off))
					   (when (elt on-off i)
					     (sum (elt blends i))))
				     p)))
			   (vertices points))))
    (write-vtk-indexed-mesh vertices (triangles n) filename)))

#+nil
(let ((points (points-from-angles '(50 60 70 60 70 50))))
  (write-mean-blends points '(nil nil nil nil nil t) "/tmp/proba.vtk"))
