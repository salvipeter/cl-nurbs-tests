(defun test-curve (v &optional (xnode *vb1*))
  (let* ((g2 (apply #'ensure-g2-continuity (halve-all-intervals (first xnode))
		    (append (rest xnode) '((100 100)))))
	 (bsc (bss-get-surface-curve g2 v :u-curve t))
	 (dir (v- (elt (control-points bsc) 1) (elt (control-points bsc) 0))))
    (list (normal-curvature (second xnode) (list 0 v) dir)
	  (normal-curvature (first xnode) (list 0 v) dir)
	  (normal-curvature g2 (list 0 v) dir))))

(defun test-curve-mean (v &optional (xnode *vb1*))
  (let ((g2 (apply #'ensure-g2-continuity (halve-all-intervals (first xnode))
		   (append (rest xnode) '((100 100))))))
    (list (bss-mean-curvature (second xnode) (list 0 v))
	  (bss-mean-curvature (first xnode) (list 0 v))
	  (bss-mean-curvature g2 (list 0 v)))))

(defun test-curve-2 (v)
  (let* ((g2 (apply #'ensure-g2-continuity (halve-all-intervals (first *vb1*))
		    (append (rest *vb1*) '((100 100)))))
	 (bsc (bss-get-surface-curve g2 v :u-curve t))
	 (dir (v- (elt (control-points bsc) 1) (elt (control-points bsc) 0))))
    (setf (elt (control-points bsc) 2)
	  (ideal-point bsc (normal-curvature (second *vb1*) (list 0 v) dir)
		       (bss-surface-normal g2 (list 0 v))))
    (flet ((cosangle (v w) (scalar-product (vnormalize v) (vnormalize w))))
      (list (normal-curvature (second *vb1*) (list 0 v) dir)
	    (* (bsc-curvature bsc 0)
	       (cosangle (bsc-out-direction bsc 0)
			 (bss-surface-normal g2 (list 0 v))))))))

(defun test-curve-3 (v)
  (let* ((g2 (apply #'ensure-g2-continuity (halve-all-intervals (first *vb1*))
		    (append (rest *vb1*) '((100 100)))))
	 (old-bsc (bss-get-surface-curve (first *vb1*) v :u-curve t))
	 (bsc (bss-get-surface-curve g2 v :u-curve t))
	 (dir (v- (elt (control-points bsc) 1) (elt (control-points bsc) 0))))
    (list
     (point-distance
      (elt (control-points old-bsc) 2)
      (ideal-point old-bsc (normal-curvature (second *vb1*) (list 0 v) dir)
		   (bss-surface-normal g2 (list 0 v))))
     (point-distance
      (elt (control-points bsc) 2)
      (ideal-point bsc (normal-curvature (second *vb1*) (list 0 v) dir)
		   (bss-surface-normal g2 (list 0 v)))))))

(defun test-curve-4 (v)
  (let* ((g2 (apply #'ensure-g2-continuity (first *vb1*)
		    (append (rest *vb1*) '((100 100)))))
	 (bsc1 (bss-get-surface-curve (first *vb1*) v :u-curve t))
	 (bsc2 (bss-get-surface-curve g2 v :u-curve t))
	 (dir (v- (elt (control-points bsc1) 1) (elt (control-points bsc1) 0))))
    (list
     (elt (control-points bsc1) 2)
     (elt (control-points bsc2) 2)
     (ideal-point bsc1 (normal-curvature (second *vb1*) (list 0 v) dir)
		  (bss-surface-normal g2 (list 0 v))))))

(defun scale-surface (surface &optional (scale 10000))
  (with-accessors ((net control-net)) surface
    (dotimes (i (array-dimension net 0))
      (dotimes (j (array-dimension net 1))
	(setf (aref net i j)
	      (mapcar (lambda (x) (* x scale)) (aref net i j)))))))


(defun ideal-point (curve curvature normal &key endp)
  (let* ((curve (if endp (bsc-reverse-parameterization curve) curve))
	 (cpts (control-points curve))
	 (p0 (elt cpts 0))
	 (p1 (elt cpts 1))
	 (tangent (vnormalize (v- p1 p0)))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (+ p 2)) (elt u 2))
		  (- (elt u (+ p 1)) (elt u 1))))))
    (list (v+ p1 (v* normal h)) tangent)))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((p (degrees surface))
	   (knots (knot-vectors surface))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 3) (* (- m 5) 3))))
	   (y (make-array (list (* (- resolution 2) 3) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	    (for bscn = (length (control-points bsc)))
	    (for bsc-dir =
		 (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
		     (elt (control-points bsc) (if endp (- bscn 1) 0))))
	    (for (p-ideal v-ideal) =
		 (ideal-point bsc (normal-curvature master uv bsc-dir)
			      (bss-surface-normal surface uv)
			      :endp endp))
	    (for c = (iter (for j from 3 to (- m 3))
			   (collect (bspline-basis (usecond knots) j
						   (usecond p) vk))))
	    (iter (for j from 0 to (- m 6))
		  (iter (for r from 0 below 3)
			(iter (for s from 0 below 3)
			      (setf (aref x (+ (* 3 (1- k)) r) (+ (* 3 j) s))
				    (if (= r s)
					(* (elt c j) (- 1 (elt v-ideal r)))
					(- (* (elt c j) (elt v-ideal s))))))))
	    (for q2 = (elt (control-points bsc) (if endp (- bscn 3) 2)))
	    (for right-side =
		 (v- (v+ p-ideal
			 (v* v-ideal
			     (scalar-product v-ideal (v- q2 p-ideal))))
		     q2))
	    (iter (for r from 0 below 3)
		  (setf (aref y (+ (* 3 (1- k)) r) 0) (elt right-side r))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
                    (v+ (aref net i1 i2)
                        (list (elt solution (+ (* (- j 3) 3) 0))
                              (elt solution (+ (* (- j 3) 3) 1))
                              (elt solution (+ (* (- j 3) 3) 2))))))))))
;;; ----

(defun ideal-distance (curve curvature &key endp)
  "nincs megszoritva"
  (let* ((curve (if endp (bsc-reverse-parameterization curve) curve))
	 (cpts (control-points curve))
	 (p0 (elt cpts 0))
	 (p1 (elt cpts 1))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve)))
    (* curvature (* d d) (/ p (1- p))
       (/ (- (elt u (+ p 2)) (elt u 2))
	  (- (elt u (+ p 1)) (elt u 1))))))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((p (degrees surface))
	   (knots (knot-vectors surface))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 4) (* (- m 5) 3))))
	   (y (make-array (list (* (- resolution 2) 4) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	    (for bscn = (length (control-points bsc)))
	    (for bsc-dir =
		 (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
		     (elt (control-points bsc) (if endp (- bscn 1) 0))))
	    (for h = (ideal-distance bsc (normal-curvature master uv bsc-dir)
				     :endp endp))
	    (for normal = (bss-surface-normal surface uv))
	    (iter (for j from 0 to (- m 6))
		  (for basis = (bspline-basis (usecond knots) (+ j 3)
					      (usecond p) vk))
		  (for c = (v* normal basis))
		  (iter (for s from 0 below 3)
			(setf (aref x (1- k) (+ (* 3 j) s)) (elt c s))
			(iter (for r from 0 below 3)
			      (setf (aref x (+ resolution -2 (* 3 (1- k)) r)
					  (+ (* 3 j) s))
				    (if (= r s) basis 0)))))
	    (for q1 = (elt (control-points bsc) (if endp (- bscn 2) 1)))
	    (for q2 = (elt (control-points bsc) (if endp (- bscn 3) 2)))
	    (setf (aref y (1- k) 0)
		  (+ h (scalar-product q1 normal)
		     (- (scalar-product q2 normal))))
	    (iter (for r from 0 below 3)
		  (setf (aref y (+ resolution -2 (* 3 (1- k)) r) 0) 0)))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
                    (v+ (aref net i1 i2)
                        (list (elt solution (+ (* (- j 3) 3) 0))
                              (elt solution (+ (* (- j 3) 3) 1))
                              (elt solution (+ (* (- j 3) 3) 2))))))))))

(defun test-k1k2 (xnode resolution u-dir endp)
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (/ (iter (for k from 0 below resolution)
	     (for u = (ufirst (if endp
				  (bss-upper-parameter (first xnode))
				  (bss-lower-parameter (first xnode)))))
	     (for v =
		  (interpolate (usecond (bss-lower-parameter (first xnode)))
			       (/ k (1- resolution))
			       (usecond (bss-upper-parameter (first xnode)))))
	     (for uv = (if u-dir (list u v) (list v u)))
	     (for other = (elt xnode (ufirst (if endp '(2 4) '(1 3)))))
	     (for (k1 k2) = (bss-principal-curvatures (first xnode) uv))
	     (for (m1 m2) = (bss-principal-curvatures other uv))
	     (sum (abs (- (+ (* k1 k1) (* k2 k2)) (+ (* m1 m1) (* m2 m2))))))
       resolution)))

(defun test-k1-k2-all-sides (xnode faired resolution)
  (let ((new (cons faired (rest xnode))))
    (mapcar (lambda (x y)
	      (/ (test-k1k2 new resolution x y)
		 (test-k1k2 xnode resolution x y)))
	    '(t t nil nil) '(nil t nil t))))

(defparameter *vb1-g2*
  (apply #'ensure-g2-continuity (halve-all-intervals (first *vb1*))
	 (append (rest *vb1*) '((100 100)))))

(defun bss-get-surface-curve (surface uv &key (u-curve t))
  (flet ((ufirst (lst) (if u-curve (first lst) (second lst)))
	 (usecond (lst) (if u-curve (second lst) (first lst))))
    (make-bspline-curve (ufirst (degrees surface))
			(ufirst (knot-vectors surface))
			(iter (for i from 0 below (ufirst (array-dimensions (control-net surface))))
			      (collect
				  (iter (for j from 0 below (usecond (array-dimensions (control-net surface))))
					(with q = (list 0 0 0))
					(for nj = (bspline-basis (usecond (knot-vectors surface)) j
								 (usecond (degrees surface)) uv))
					(for ij = (if u-curve (list i j) (list j i)))
					(setf q (v+ q (v* (aref (control-net surface)
								(first ij) (second ij))
							  nj)))
					(finally (return q))))))))

;;; ---

;;; 4 oldalra, elmentve a twistpoziciokat
;;; majd a twistek atlagait beallitva twistek nelkul

(defun ensure-g2-one-side-with-twists (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((p (degrees surface))
	   (knots (knot-vectors surface))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 3) (* (- m 3) 3))))
	   (y (make-array (list (* (- resolution 2) 3) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	    (for bscn = (length (control-points bsc)))
	    (for bsc-dir =
		 (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
		     (elt (control-points bsc) (if endp (- bscn 1) 0))))
	    (for ideal = (ideal-point bsc (normal-curvature master uv bsc-dir)
				      (bss-surface-normal surface uv)
				      :endp endp))
	    (for c = (iter (for j from 2 to (- m 2))
			   (collect (bspline-basis (usecond knots) j
						   (usecond p) vk))))
	    (iter (for j from 0 to (- m 4))
		  (iter (for r from 0 below 3)
			(iter (for s from 0 below 3)
			      (setf (aref x (+ (* 3 (1- k)) r) (+ (* 3 j) s))
				    (if (= r s) (elt c j) 0)))))
	    (for right-side =
		 (v- ideal (elt (control-points bsc) (if endp (- bscn 3) 2))))
	    (iter (for r from 0 below 3)
		  (setf (aref y (+ (* 3 (1- k)) r) 0) (elt right-side r))))
      (let ((solution (least-squares x y)))
        (iter (for j from 2 to (- m 2))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
                    (v+ (aref net i1 i2)
                        (list (elt solution (+ (* (- j 2) 3) 0))
                              (elt solution (+ (* (- j 2) 3) 1))
                              (elt solution (+ (* (- j 2) 3) 2))))))))))

(defun ensure-g2-continuity-with-twists (surface lsurface rsurface dsurface usurface res)
  (let ((result (copy-bspline-surface surface))
	(n (array-dimensions (control-net surface)))
	nw ne sw se)
    (ensure-g2-one-side-with-twists result lsurface (second res) :u-dir t :endp nil)
    (setf nw (aref (control-net result) 2 (- (second n) 3))
	  sw (aref (control-net result) 2 2))
    (ensure-g2-one-side-with-twists result rsurface (second res) :u-dir t :endp t)
    (setf ne (aref (control-net result) (- (first n) 3) (- (second n) 3))
	  se (aref (control-net result) (- (first n) 3) 2))
    (ensure-g2-one-side-with-twists result dsurface (first res) :u-dir nil :endp nil)
    (setf sw (affine-combine sw 1/2 (aref (control-net result) 2 2))
	  se (affine-combine se 1/2 (aref (control-net result) (- (first n) 3) 2)))
    (ensure-g2-one-side-with-twists result usurface (first res) :u-dir nil :endp t)
    (setf nw (affine-combine nw 1/2 (aref (control-net result) 2 (- (second n) 3)))
	  ne (affine-combine ne 1/2 (aref (control-net result) (- (first n) 3) (- (second n) 3))))
    ;; setting the twists
    (setf (aref (control-net result) 2 (- (second n) 3)) nw
	  (aref (control-net result) 2 2) sw
	  (aref (control-net result) (- (first n) 3) (- (second n) 3)) ne
	  (aref (control-net result) (- (first n) 3) 2) se)
    (ensure-g2-one-side result lsurface (second res) :u-dir t :endp nil)
    (ensure-g2-one-side result rsurface (second res) :u-dir t :endp t)
    (ensure-g2-one-side result dsurface (first res) :u-dir nil :endp nil)
    (ensure-g2-one-side result usurface (first res) :u-dir nil :endp t)
    result))

;;; ---

;;; elteres az idealis ponttol atlagosan

(defun deviation-from-ideal (surface master resolution &key u-dir endp)
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low)))
      (/ (iter (for k from 1 below (1- resolution))
	       (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	       (for uv = (if u-dir (list u vk) (list vk u)))
	       (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	       (for bscn = (length (control-points bsc)))
	       (for bsc-dir =
		    (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
			(elt (control-points bsc) (if endp (- bscn 1) 0))))
	       (for ideal = (ideal-point bsc
					 (normal-curvature master uv bsc-dir)
					 (bss-surface-normal surface uv)
					 :endp endp))
	       (sum (point-distance
		     ideal
		     (elt (control-points bsc) (if endp (- bscn 3) 2)))))
	 (- resolution 2)))))

;;; elteres a g2-siktol

(defun deviation-from-ideal (surface master resolution &key u-dir endp)
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low)))
      (/ (iter (for k from 1 below (1- resolution))
	       (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	       (for uv = (if u-dir (list u vk) (list vk u)))
	       (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	       (for bscn = (length (control-points bsc)))
	       (for bsc-dir =
		    (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
			(elt (control-points bsc) (if endp (- bscn 1) 0))))
	       (for normal = (bss-surface-normal surface uv))
	       (for ideal = (ideal-point bsc
					 (normal-curvature master uv bsc-dir)
					 normal :endp endp))
	       (sum (abs
		     (scalar-product
		      (v- ideal
			  (elt (control-points bsc) (if endp (- bscn 3) 2)))
		      normal))))
	 (- resolution 2)))))

;;; elteres normalgorbuletben

(defun deviation-from-ideal (surface master resolution &key u-dir endp)
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low)))
      (/ (iter (for k from 1 below (1- resolution))
	       (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	       (for uv = (if u-dir (list u vk) (list vk u)))
	       (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	       (for bscn = (length (control-points bsc)))
	       (for bsc-dir =
		    (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
			(elt (control-points bsc) (if endp (- bscn 1) 0))))
	       (for normal = (bss-surface-normal surface uv))
	       (for c = (bsc-evaluate bsc u :derivative 1))
	       (for cc = (bsc-evaluate bsc u :derivative 2))
	       (for curve-normal = (cross-product c cc))
	       (for theta = (scalar-product (vnormalize curve-normal) normal))
	       (for nc = (normal-curvature master uv bsc-dir))
	       (for nc2 = (normal-curvature surface uv bsc-dir))
	       (sum (abs (- nc nc2))))
	 (- resolution 2)))))

(deviation-from-ideal (first *vb1*) (second *vb1*) 100 :u-dir t :endp nil)
(deviation-from-ideal *vb1-g2* (second *vb1*) 100 :u-dir t :endp nil)
(deviation-from-ideal (first *vb1*) (third *vb1*) 100 :u-dir t :endp t)
(deviation-from-ideal *vb1-g2* (third *vb1*) 100 :u-dir t :endp t)
(deviation-from-ideal (first *vb1*) (fourth *vb1*) 100 :u-dir nil :endp nil)
(deviation-from-ideal *vb1-g2* (fourth *vb1*) 100 :u-dir nil :endp nil)
(deviation-from-ideal (first *vb1*) (fifth *vb1*) 100 :u-dir nil :endp t)
(deviation-from-ideal *vb1-g2* (fifth *vb1*) 100 :u-dir nil :endp t)

(defun test-curvature (surface v &optional (u 0))
  (let* ((bsc (bss-get-surface-curve surface v :u-curve t))
	 (dir (v- (elt (control-points bsc) 1) (elt (control-points bsc) 0))))
    (flet ((angle (v w) (acos (scalar-product (vnormalize v) (vnormalize w)))))
      (list (normal-curvature surface (list u v) (vnormalize dir))
	    (* (bsc-curvature bsc u)
	       (cos (angle (cross-product
			    (bsc-evaluate bsc u :derivative 1)
			    (bsc-evaluate bsc u :derivative 2))
			   (bss-surface-normal surface (list u v)))))
	    (* (bsc-curvature bsc u)
	       (cos (angle (cross-product
			    (cross-product
			     (bsc-evaluate bsc u :derivative 1)
			     (bsc-evaluate bsc u :derivative 2))
			    (bsc-evaluate bsc u :derivative 1))
			   (bss-surface-normal surface (list u v)))))
	    (/ (scalar-product (bsc-evaluate bsc u :derivative 2)
			       (bss-surface-normal surface (list u v)))
	       (scalar-product (bsc-evaluate bsc u :derivative 1)
			       (bsc-evaluate bsc u :derivative 1)))))))

(defun test-normal-curvature (v)
  (let* ((g2 (apply #'ensure-g2-continuity (halve-all-intervals (first *vb1*))
		    (append (rest *vb1*) '((100 100)))))
	 (bsc (bss-get-surface-curve g2 v :u-curve t))
	 (dir (v- (elt (control-points bsc) 1) (elt (control-points bsc) 0))))
    (format t "ISOCURVE DIRECTION~%Master:~%~a~%Original:~%~a~%New:~%~a~%~%"
	    (normal-curvature (second *vb1*) (list 0 v) dir)
	    (normal-curvature (first *vb1*) (list 0 v) dir)
	    (normal-curvature g2 (list 0 v) dir))
    (iter (with normal = (bss-surface-normal (second *vb1*) (list 0 v)))
	  (for angle from (- pi) to pi by 0.3)
	  (with du = (bss-evaluate (second *vb1*) (list 0 v) :derivative '(1 0)))
	  (with u-dir = (vnormalize du))
	  (with v-dir = (cross-product normal u-dir))
	  (for d = (v+ (v* u-dir (cos angle)) (v* v-dir (sin angle))))
	  (format t "~a:~%Master:~%~a~%Original:~%~a~%New:~%~a~%~%"
		  d
		  (normal-curvature (second *vb1*) (list 0 v) d)
		  (normal-curvature (first *vb1*) (list 0 v) d)
		  (normal-curvature g2 (list 0 v) d)))))

(defun print-normal-curvature (v)
  (let ((g2 (apply #'ensure-g2-continuity (halve-all-intervals (first *vb1*))
		   (append (rest *vb1*) '((100 100))))))
    (iter (with normal = (bss-surface-normal (second *vb1*) (list 0 v)))
	  (for angle from (- pi) to pi by 0.01)
	  (with du = (bss-evaluate (second *vb1*) (list 0 v) :derivative '(1 0)))
	  (with u-dir = (vnormalize du))
	  (with v-dir = (cross-product normal u-dir))
	  (for d = (v+ (v* u-dir (cos angle)) (v* v-dir (sin angle))))
	  (for k = (abs (normal-curvature g2 (list 0 v) d)))
	  (format t "~f ~f~%"
		  (* (cos angle) k) (* (sin angle) k)))))

(defun generate-normal-curvature-images (master original slave resolution n
					 filename &key u-dir v-start v-end u
					 (scaling 1))
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "%!PS~%")
    (let ((red '(1 0 0))
	  (green '(0 1 0))
	  (blue '(0 0 1))
	  (yellow '(1 1 0)))
      (labels ((setcolor (color) (format s " ~{~a ~}setrgbcolor~%" color))
	       (write-curvatures (surface color uv dir)
		 (setcolor color)
		 (iter (with v-dir = (vnormalize
				      (bss-evaluate surface uv
						    :derivative (if u-dir
								    '(0 1)
								    '(1 0)))))
		       (with other = (cross-product
				      (bss-surface-normal surface uv) v-dir))
		       (with (x y) = (in-system other v-dir dir))
		       (with dir-angle = (atan y x))
		       (for firstp first t then nil)
		       (for i from 0 below n)
		       (for angle = (interpolate (- pi) (/ i (1- n)) pi))
		       (for d = (v+ (v* other (cos angle))
				    (v* v-dir (sin angle))))
		       (for k = (abs (normal-curvature surface uv d)))
		       (when (and (<= angle dir-angle)
				  (< dir-angle (+ angle (/ (* 2 pi) n))))
			 (format s " ~f ~f ~:[lineto~;moveto~]~%"
			       (+ 299 (* (cos angle) k scaling))
			       (+ 421 (* (sin angle) k scaling))
			       firstp)
			 (format s "stroke~%newpath~%")
			 (setcolor red)
			 (format s " ~f ~f 10 0 360 arc~%stroke~%newpath~%"
				 (+ 299 (* (cos angle) k scaling))
				 (+ 421 (* (sin angle) k scaling)))
			 (setf firstp t)
			 (setcolor color))
		       (format s " ~f ~f ~:[lineto~;moveto~]~%"
			       (+ 299 (* (cos angle) k scaling))
			       (+ 421 (* (sin angle) k scaling))
			       firstp))))
	(iter (for k from 0 below resolution)
	      (for v = (interpolate v-start (/ k (1- resolution)) v-end))
	      (for uv = (if u-dir (list u v) (list v u)))
	      (for dir = (vnormalize
			  (bss-evaluate original uv
					:derivative (if u-dir '(1 0) '(0 1)))))
	      (format s "newpath~%")
	      (write-curvatures master blue uv dir)
	      (format s "stroke~%newpath~%")
	      (write-curvatures original yellow uv dir)
	      (format s "stroke~%newpath~%")
	      (write-curvatures slave green uv dir)
	      (format s "stroke~%showpage~%"))))))

;;; example use:
(generate-normal-curvature-images
 (second *vb1*) (first *vb1*) *vb1-g2* 200 300 "/home/salvi/curvature.ps"
 :u-dir t :v-start 0 :v-end 1 :u 0 :scaling 10)

(generate-normal-curvature-images
 (second *xnode*) (first *xnode*) *xnode-g2* 200 300 "/home/salvi/curvature.ps"
 :u-dir t :v-start 1 :v-end 2 :u 1 :scaling 1)

;;; new idea: two curves for every point
(defun ideal-plane (curve curvature normal &key endp)
  (let* ((curve (if endp (bsc-reverse-parameterization curve) curve))
	 (cpts (control-points curve))
	 (p0 (elt cpts 0))
	 (p1 (elt cpts 1))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (+ p 2)) (elt u 2))
		  (- (elt u (+ p 1)) (elt u 1))))))
    (list (v+ p1 (v* normal h)) normal)))

(defun plane-plane-intersection (p1 p2)
  "P1 and P2 are given as (POINT NORMAL)."
  (let ((dir (cross-product (second p1) (second p2))))
    (destructuring-bind ((n1x n1y n1z) (n2x n2y n2z))
	(list (second p1) (second p2))
      (let* ((i (position 0 dir :test-not #'=))
	     (m (make-array '(2 2) :initial-contents
			    `(,(append (if (= i 0) nil `(,n1x))
				       (if (= i 1) nil `(,n1y))
				       (if (= i 2) nil `(,n1z)))
			       ,(append (if (= i 0) nil `(,n2x))
					(if (= i 1) nil `(,n2y))
					(if (= i 2) nil `(,n2z))))))
	     (b (vector (apply #'scalar-product p1)
			(apply #'scalar-product p2))))
	(list (let ((v (coerce (lu-solve m b) 'list)))
		(case i
		  (0 (cons 0 v))
		  (1 (list (first v) 0 (second v)))
		  (2 (append v '(0)))))
	      dir)))))

(defun project-point-to-line (point line)
  "LINE is given as (POINT DIRECTION)."
  (v+ (first line)
      (v* (second line)
	  (scalar-product (v- point (first line)) (second line)))))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((p (degrees surface))
	   (knots (knot-vectors surface))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 3) (* (- m 5) 3))))
	   (y (make-array (list (* (- resolution 2) 3) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for vk1 = (+ v-low (/ (* (- k 1/2) length-v) (1- resolution))))
	    (for vk2 = (+ v-low (/ (* (+ k 1/2) length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for uv1 = (if u-dir (list u vk1) (list vk1 u)))
	    (for uv2 = (if u-dir (list u vk2) (list vk2 u)))
	    (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	    (for bscn = (length (control-points bsc)))
	    (for bsc1 = (let ((curve (copy-bspline-curve bsc)))
			  (setf (elt (control-points curve)
				     (if endp (1- bscn) 0))
				(bss-evaluate surface uv1))
			  curve))
	    (for bsc2 = (let ((curve (copy-bspline-curve bsc)))
			  (setf (elt (control-points curve)
				     (if endp (1- bscn) 0))
				(bss-evaluate surface uv2))
			  curve))
	    (for bsc1-dir =
		 (v- (elt (control-points bsc1) (if endp (- bscn 2) 1))
		     (elt (control-points bsc1) (if endp (- bscn 1) 0))))
	    (for bsc2-dir =
		 (v- (elt (control-points bsc2) (if endp (- bscn 2) 1))
		     (elt (control-points bsc2) (if endp (- bscn 1) 0))))
	    (for ideal1 = (ideal-plane bsc1
				       (normal-curvature master uv1 bsc1-dir)
				       (bss-surface-normal surface uv1)
				      :endp endp))
	    (for ideal2 = (ideal-plane bsc2
				       (normal-curvature master uv2 bsc2-dir)
				       (bss-surface-normal surface uv2)
				      :endp endp))
	    (for ideal-line = (plane-plane-intersection ideal1 ideal2))
	    (for ideal = (project-point-to-line
			  (elt (control-points bsc) (if endp (- bscn 3) 2))
			  ideal-line))
	    (format t "~%Point ~d~%i1: ~a~%i2: ~a~%il: ~a~%i: ~a~%"
		    k ideal1 ideal2 ideal-line ideal)
	    (format t "~%BSC1~%~a~%~a~%~a~%"
		    (elt (control-points bsc1) (if endp (- bscn 1) 0))
		    (elt (control-points bsc1) (if endp (- bscn 2) 1))
		    (elt (control-points bsc1) (if endp (- bscn 3) 2)))
	    (format t "~%BSC2~%~a~%~a~%~a~%"
		    (elt (control-points bsc2) (if endp (- bscn 1) 0))
		    (elt (control-points bsc2) (if endp (- bscn 2) 1))
		    (elt (control-points bsc2) (if endp (- bscn 3) 2)))
	    (for c = (iter (for j from 3 to (- m 3))
			   (collect (bspline-basis (usecond knots) j
						   (usecond p) vk))))
	    (iter (for j from 0 to (- m 6))
		  (iter (for r from 0 below 3)
			(iter (for s from 0 below 3)
			      (setf (aref x (+ (* 3 (1- k)) r) (+ (* 3 j) s))
				    (if (= r s) (elt c j) 0)))))
	    (for right-side =
		 (v- ideal (elt (control-points bsc) (if endp (- bscn 3) 2))))
	    (iter (for r from 0 below 3)
		  (setf (aref y (+ (* 3 (1- k)) r) 0) (elt right-side r))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
                    (v+ (aref net i1 i2)
                        (list (elt solution (+ (* (- j 3) 3) 0))
                              (elt solution (+ (* (- j 3) 3) 1))
                              (elt solution (+ (* (- j 3) 3) 2))))))))))

;;; --- ha nincs benne a gorbe a normalos sikban, projekcio oda-vissza
;;; [ez valoszinuleg egy jo dolog, meg ha most nem is produkal semmit]
;;; ld. Hermann/Varady: section 6 utolso bekezdes

(defun project-point-to-plane (point plane)
  "PLANE is given as \(POINT NORMAL)."
  (destructuring-bind (origin normal) plane
    (v+ point (v* normal (scalar-product (v- origin point) normal)))))

(defun ideal-point (curve curvature normal plane &key endp)
  "meg van szoritva hogy a feluleti normalis es az erinto altal meghatarozott
sikban legyen"
  (let* ((curve (if endp (bsc-reverse-parameterization curve) curve))
	 (cpts (control-points curve))
	 (p0 (elt cpts 0))
	 (p1 (elt cpts 1))
	 (p2 (project-point-to-plane (elt cpts 2) plane))
	 (tangent (vnormalize (v- p1 p0)))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (+ p 2)) (elt u 2))
		  (- (elt u (+ p 1)) (elt u 1)))))
	 (q (v+ p1 (v* normal h)))
	 (l (scalar-product (v- p2 q) tangent)))
    (project-point-to-plane
     (v+ p1 (v* tangent l) (v* normal h))
     (list p0 (cross-product (v- p1 p0) (v- (elt cpts 2) p0))))))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((p (degrees surface))
	   (knots (knot-vectors surface))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 3) (* (- m 5) 3))))
	   (y (make-array (list (* (- resolution 2) 3) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	    (for bscn = (length (control-points bsc)))
	    (for bsc-dir =
		 (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
		     (elt (control-points bsc) (if endp (- bscn 1) 0))))
	    ;; csak ez valtozott:
	    (for ideal = (ideal-point bsc (normal-curvature master uv bsc-dir)
				      (bss-surface-normal surface uv)
				      (list (elt (control-points bsc)
						 (if endp (- bscn 1) 0))
					    (cross-product
					     (bss-surface-normal surface uv)
					     bsc-dir))
				      :endp endp))
	    (for c = (iter (for j from 3 to (- m 3))
			   (collect (bspline-basis (usecond knots) j
						   (usecond p) vk))))
	    (iter (for j from 0 to (- m 6))
		  (iter (for r from 0 below 3)
			(iter (for s from 0 below 3)
			      (setf (aref x (+ (* 3 (1- k)) r) (+ (* 3 j) s))
				    (if (= r s) (elt c j) 0)))))
	    (for right-side =
		 (v- ideal (elt (control-points bsc) (if endp (- bscn 3) 2))))
	    (iter (for r from 0 below 3)
		  (setf (aref y (+ (* 3 (1- k)) r) 0) (elt right-side r))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
                    (v+ (aref net i1 i2)
                        (list (elt solution (+ (* (- j 3) 3) 0))
                              (elt solution (+ (* (- j 3) 3) 1))
                              (elt solution (+ (* (- j 3) 3) 2))))))))))

;;; --- surface curve u(t),v(t)

(defun surface-curve (surface v &key type)
  "TYPE is UP or DOWN."
  (let ((umin (first (bss-lower-parameter surface)))
	(umax (first (bss-upper-parameter surface)))
	(vmin (second (bss-lower-parameter surface)))
	(vmax (second (bss-upper-parameter surface)))
	(n (array-dimension (control-net surface) 0))
	(m (array-dimension (control-net surface) 1))
	(uknots (first (knot-vectors surface)))
	(vknots (second (knot-vectors surface)))
	(udegree (first (degrees surface)))
	(vdegree (second (degrees surface))))
    (lambda (x)
      (let ((result (list 0 0 0))
	    (u (+ umin (* x (- umax umin))))
	    (vv (ecase type
		  (up (+ v (* x (- vmax v))))
		  (down (- v (* x (- v vmin)))))))
	(iter (for i from 0 below n)
	      (iter (for j from 0 below m)
		    (for alpha = (* (bspline-basis uknots i udegree u)
				    (bspline-basis vknots j vdegree vv)))
		    (setf result
			  (v+ result
			      (v* (aref (control-net surface) i j) alpha)))))
	result))))

(defun surface-curve-derivative (surface v &key type)
  "TYPE is UP or DOWN."
  (let ((umin (first (bss-lower-parameter surface)))
	(umax (first (bss-upper-parameter surface)))
	(vmin (second (bss-lower-parameter surface)))
	(vmax (second (bss-upper-parameter surface)))
	(n (array-dimension (control-net surface) 0))
	(m (array-dimension (control-net surface) 1))
	(uknots (first (knot-vectors surface)))
	(vknots (second (knot-vectors surface)))
	(udegree (first (degrees surface)))
	(vdegree (second (degrees surface))))
    (lambda (x)
      (let ((result (list 0 0 0))
	    (u (+ umin (* x (- umax umin))))
	    (vv (ecase type
		  (up (+ v (* x (- vmax v))))
		  (down (- v (* x (- v vmin)))))))
	(iter (for i from 0 below n)
	      (iter (for j from 0 below m)
		    (for alpha = (+ (* (bspline-basis uknots i udegree u
						      :derivative 1)
				       (bspline-basis vknots j vdegree vv)
				       (- umax umin))
				    (* (bspline-basis uknots i udegree u)
				       (bspline-basis vknots j vdegree vv
						      :derivative 1)
				       (ecase type
					 (up (- vmax v))
					 (down (- v vmin))))))
		    (setf result
			  (v+ result
			      (v* (aref (control-net surface) i j) alpha)))))
	result))))

(defun surface-curve-second-derivative (surface v &key type)
  "TYPE is UP or DOWN."
  (let ((umin (first (bss-lower-parameter surface)))
	(umax (first (bss-upper-parameter surface)))
	(vmin (second (bss-lower-parameter surface)))
	(vmax (second (bss-upper-parameter surface)))
	(n (array-dimension (control-net surface) 0))
	(m (array-dimension (control-net surface) 1))
	(uknots (first (knot-vectors surface)))
	(vknots (second (knot-vectors surface)))
	(udegree (first (degrees surface)))
	(vdegree (second (degrees surface))))
    (lambda (x)
      (let ((result (list 0 0 0))
	    (u (+ umin (* x (- umax umin))))
	    (vv (ecase type
		  (up (+ v (* x (- vmax v))))
		  (down (- v (* x (- v vmin))))))
	    (du (- umax umin))
	    (dv (ecase type (up (- vmax v)) (down (- v vmin)))))
	(iter (for i from 0 below n)
	      (iter (for j from 0 below m)
		    (for alpha = (+ (* (bspline-basis uknots i udegree u
						      :derivative 2)
				       (bspline-basis vknots j vdegree vv)
				       du du)
				    (* (bspline-basis uknots i udegree u
						      :derivative 1)
				       (bspline-basis vknots j vdegree vv
						      :derivative 1)
				       2 du dv)
				    (* (bspline-basis uknots i udegree u)
				       (bspline-basis vknots j vdegree vv
						      :derivative 2)
				       dv dv)))
		    (setf result
			  (v+ result
			      (v* (aref (control-net surface) i j) alpha)))))
	result))))

(let ((upcurve (surface-curve (first *vb1*) 0.4 :type 'up))
      (downcurve (surface-curve (first *vb1*) 0.4 :type 'down)))
  (mapc (lambda (curve filename)
	  (write-points-vtk (iter (for x from 0 to 1 by 0.01d0)
				  (collect (funcall curve x)))
			    filename))
	(list upcurve downcurve)
	(list "/home/salvi/upcurve.vtk" "/home/salvi/downcurve.vtk")))

(defun surface-curve-derivatives (surface v &key u-dir endp type)
  "Returns the derivatives at the end of the curve.

TYPE is UP or DOWN."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((umin (ufirst (bss-lower-parameter surface)))
	   (umax (ufirst (bss-upper-parameter surface)))
	   (vmin (usecond (bss-lower-parameter surface)))
	   (vmax (usecond (bss-upper-parameter surface)))
	   (n (ufirst (array-dimensions (control-net surface))))
	   (m (usecond (array-dimensions (control-net surface))))
	   (uknots (ufirst (knot-vectors surface)))
	   (vknots (usecond (knot-vectors surface)))
	   (udegree (ufirst (degrees surface)))
	   (vdegree (usecond (degrees surface)))
	   (d '(0 0 0))
	   (dd '(0 0 0))
	   (alpha '())
	   (u (if endp umax umin))
	   (du (if endp (- umin umax) (- umax umin)))
	   (dv (ecase type (up (- vmax v)) (down (- v vmin)))))
      (iter (for i from 0 below n)
	    (iter (for j from 0 below m)
		  (for alpha1 = (+ (* (bspline-basis uknots i udegree u
						     :derivative 1)
				      (bspline-basis vknots j vdegree v)
				      du)
				   (* (bspline-basis uknots i udegree u)
				      (bspline-basis vknots j vdegree v
						     :derivative 1)
				      dv)))
		  (for alpha2 = (+ (* (bspline-basis uknots i udegree u
						     :derivative 2)
				      (bspline-basis vknots j vdegree v)
				      du du)
				   (* (bspline-basis uknots i udegree u
						     :derivative 1)
				      (bspline-basis vknots j vdegree v
						     :derivative 1)
				      2 du dv)
				   (* (bspline-basis uknots i udegree u)
				      (bspline-basis vknots j vdegree v
						     :derivative 2)
				      dv dv)))
		  (for p = (if u-dir
			       (aref (control-net surface) i j)
			       (aref (control-net surface) j i)))
		  (setf d (v+ d (v* p alpha1)))
		  (if (and (= i 2) (<= 3 j (- m 4)))
		      (push alpha2 alpha)
		      (setf dd (v+ dd (v* p alpha2))))))
      (list d dd (nreverse alpha)))))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 2) (* (- m 5) 3))))
	   (y (make-array (list (* (- resolution 2) 2) 1))))
      (dolist (dir '(up down))
	(iter (with start = (if (eq dir 'up) 0 (- resolution 2)))
	      (for k from 1 below (1- resolution))
	      (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	      (for uv = (if u-dir (list u vk) (list vk u)))
	      (for (d1 d2part alpha) =
		   (surface-curve-derivatives surface vk :u-dir u-dir
					      :endp endp :type dir))
	      (for target-curvature = (normal-curvature master uv d1))
	      (for normal = (bss-surface-normal surface uv))
	      (iter (for j from 0 to (- m 6))
		    (iter (for s from 0 below 3)
			  (setf (aref x (+ start k -1) (+ (* 3 j) s))
				(* (elt alpha j) (elt normal s)))))
	      (setf (aref y (+ start k -1) 0)
		    (- (* target-curvature (scalar-product d1 d1))
		       (scalar-product d2part normal)))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
		    (list (elt solution (+ (* (- j 3) 3) 0))
			  (elt solution (+ (* (- j 3) 3) 1))
			  (elt solution (+ (* (- j 3) 3) 2)))))))))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Benne van minden P2j ponthoz egy P2j_new = P2j a matrixban."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (+ (* (- resolution 2) 2) (* (- m 5) 3))
				(* (- m 5) 3))))
	   (y (make-array (list (+ (* (- resolution 2) 2) (* (- m 5) 3)) 1))))
      (dolist (dir '(up down))
	(iter (with start = (if (eq dir 'up) 0 (- resolution 2)))
	      (for k from 1 below (1- resolution))
	      (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	      (for uv = (if u-dir (list u vk) (list vk u)))
	      (for (d1 d2part alpha) =
		   (surface-curve-derivatives surface vk :u-dir u-dir
					      :endp endp :type dir))
	      (for target-curvature = (normal-curvature master uv d1))
	      (for normal = (bss-surface-normal surface uv))
	      (iter (for j from 0 to (- m 6))
		    (iter (for s from 0 below 3)
			  (setf (aref x (+ start (1- k)) (+ (* 3 j) s))
				(* (elt alpha j) (elt normal s)))))
	      (setf (aref y (+ start (1- k)) 0)
		    (- (* target-curvature (scalar-product d1 d1))
		       (scalar-product d2part normal)))))
      (iter (for k from 0 to (- m 6))
	    (iter (for r from 0 below 3)
		  (iter (for j from 0 below (- m 6))
			(iter (for s from 0 below 3)
			      (setf (aref x (+ (* (- resolution 2) 2)
					       (+ (* 3 k) r))
					  (+ (* 3 j) s))
				    (if (and (= j k) (= r s)) 1 0))))
		  (setf (aref y (+ (* (- resolution 2) 2) (+ (* 3 k) r)) 0)
			(if u-dir
			    (elt (aref (control-net surface) index (+ k 3)) r)
			    (elt (aref (control-net surface) (+ k 3) index) r)))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
		    (list (elt solution (+ (* (- j 3) 3) 0))
			  (elt solution (+ (* (- j 3) 3) 1))
			  (elt solution (+ (* (- j 3) 3) 2)))))))))

;;; valtozat: csak normalisiranyu valtozas
;;; JO!!!

(defun surface-curve-derivatives (surface v &key u-dir endp type)
  "Returns the derivatives at the end of the curve.

TYPE is UP or DOWN."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((umin (ufirst (bss-lower-parameter surface)))
	   (umax (ufirst (bss-upper-parameter surface)))
	   (vmin (usecond (bss-lower-parameter surface)))
	   (vmax (usecond (bss-upper-parameter surface)))
	   (n (ufirst (array-dimensions (control-net surface))))
	   (m (usecond (array-dimensions (control-net surface))))
	   (uknots (ufirst (knot-vectors surface)))
	   (vknots (usecond (knot-vectors surface)))
	   (udegree (ufirst (degrees surface)))
	   (vdegree (usecond (degrees surface)))
	   (index (if endp (- n 3) 2))
	   (d '(0 0 0))
	   (dd '(0 0 0))
	   (alpha '())
	   (u (if endp umax umin))
	   (du (- umax umin))
	   (dv (ecase type (up (- vmax v)) (down (- v vmin)))))
      (iter (for i from 0 below n)
	    (iter (for j from 0 below m)
		  (for alpha1 =
		       (+ (* (bspline-basis uknots i udegree u :derivative 1)
			     (bspline-basis vknots j vdegree v)
			     du)
			  (* (bspline-basis uknots i udegree u)
			     (bspline-basis vknots j vdegree v :derivative 1)
			     dv)))
		  (for alpha2 =
		       (+ (* (bspline-basis uknots i udegree u :derivative 2)
			     (bspline-basis vknots j vdegree v)
			     du du)
			  (* (bspline-basis uknots i udegree u :derivative 1)
			     (bspline-basis vknots j vdegree v :derivative 1)
			     2 du dv)
			  (* (bspline-basis uknots i udegree u)
			     (bspline-basis vknots j vdegree v :derivative 2)
			     dv dv)))
		  (for p = (if u-dir
			       (aref (control-net surface) i j)
			       (aref (control-net surface) j i)))
		  (setf d (v+ d (v* p alpha1)))
		  (setf dd (v+ dd (v* p alpha2)))
		  (when (and (= i index) (<= 3 j (- m 4)))
		    (push alpha2 alpha))))
      (list d dd (nreverse alpha)))))

(defun control-normal (surface i j)
  (let ((net (control-net surface)))
    (vnormalize
     (cross-product (v- (aref net (1+ i) j) (aref net (1- i) j))
		    (v- (aref net i (1+ j)) (aref net i (1- j)))))))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 2) (- m 5))))
	   (y (make-array (list (* (- resolution 2) 2) 1))))
      (dolist (dir '(up down))
	(iter (with start = (if (eq dir 'up) 0 (- resolution 2)))
	      (for k from 1 below (1- resolution))
	      (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	      (for uv = (if u-dir (list u vk) (list vk u)))
	      (for (d1 d2 alpha) =
		   (surface-curve-derivatives surface vk :u-dir u-dir
					      :endp endp :type dir))
	      (for target-curvature = (normal-curvature master uv d1))
	      (for normal = (bss-surface-normal surface uv))
	      (iter (for j from 0 to (- m 6))
		    (setf (aref x (+ start k -1) j)
			  (* (elt alpha j)
			     (scalar-product
			      (if u-dir
				  (control-normal surface index (+ j 3))
				  (control-normal surface (+ j 3) index))
			      normal))))
	      (setf (aref y (+ start k -1) 0)
		    (- (* target-curvature (scalar-product d1 d1))
		       (scalar-product d2 normal)))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
	      (for normal = (if u-dir
				(control-normal surface index j)
				(control-normal surface j index)))
              (setf (aref net i1 i2)
		    (v+ (aref net i1 i2)
			(v* normal (elt solution (- j 3))))))))))

;;; --- kuka ---

(defun ideal-point (curve curvature normal &key endp)
  "meg van szoritva hogy a feluleti normalis es az erinto altal meghatarozott
sikban legyen"
  (let* ((curve (if endp (bsc-reverse-parameterization curve) curve))
	 (cpts (control-points curve))
	 (p0 (elt cpts 0))
	 (p1 (elt cpts 1))
	 (p2 (elt cpts 2))
	 (tangent (vnormalize (v- p1 p0)))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (+ p 2)) (elt u 2))
		  (- (elt u (+ p 1)) (elt u 1)))))
	 (q (v+ p1 (v* normal h)))
	 (l (scalar-product (v- p2 q) tangent)))
    (v+ p1 (v* tangent l) (v* normal h))))

(defun ideal-point (curve curvature normal &key endp)
  "nincs megszoritva"
  (let* ((curve (if endp (bsc-reverse-parameterization curve) curve))
	 (cpts (control-points curve))
	 (p0 (elt cpts 0))
	 (p1 (elt cpts 1))
	 (p2 (elt cpts 2))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (+ p 2)) (elt u 2))
		  (- (elt u (+ p 1)) (elt u 1))))))
    (v+ p2 (v* normal (- h (scalar-product (v- p2 p1) normal))))))

;; (defun set-one-g2-twist (surface u-master v-master u-endp v-endp)
;;   (let* ((u (elt (first (knot-vectors surface))
;; 		 (if u-endp
;; 		     (- (length (first (knot-vectors surface)))
;; 			(first (degrees surface))
;; 			2)))
;; 	   (if u-endp
;; 	       (first (bss-upper-parameter surface))
;; 	       (first (bss-lower-parameter surface))))
;; 	 (v (if v-endp
;; 		(second (bss-upper-parameter surface))
;; 		(second (bss-lower-parameter surface))))
;; 	 (bsc-u (bss-construction-curve surface (if v-endp (- m 2) 2)
;; 					:u-direction t))
;; 	 (bsc-v (bss-construction-curve surface (if u-endp (- n 2) 2)
;; 					:u-direction nil)))
;;     ))

;; (defun set-g2-twists (xnode)
;;   (set-one-g2-twist (first xnode) (second xnode) (fourth xnode) nil nil)
;;   (set-one-g2-twist (first xnode) (second xnode) (fifth xnode)  nil t)
;;   (set-one-g2-twist (first xnode) (third xnode)  (fourth xnode) t   nil)
;;   (set-one-g2-twist (first xnode) (third xnode)  (fifth xnode)  t   t)
;;   xnode)

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((p (degrees surface))
	   (knots (knot-vectors surface))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 3) (* (- m 5) 3))))
	   (y (make-array (list (* (- resolution 2) 3) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	    (for bscn = (length (control-points bsc)))
	    (for bsc-dir =
		 (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
		     (elt (control-points bsc) (if endp (- bscn 1) 0))))
	    (for ideal = (ideal-point bsc (normal-curvature master uv bsc-dir)
				      (bss-surface-normal surface uv)
				      :endp endp))
	    (for c = (iter (for j from 3 to (- m 3))
			   (collect (bspline-basis (usecond knots) j
						   (usecond p) vk))))
	    (iter (for j from 0 to (- m 6))
		  (iter (for r from 0 below 3)
			(iter (for s from 0 below 3)
			      (setf (aref x (+ (* 3 (1- k)) r) (+ (* 3 j) s))
				    (if (= r s) (elt c j) 0)))))
	    (for right-side =
		 (v- ideal (elt (control-points bsc) (if endp (- bscn 3) 2))))
	    (iter (for r from 0 below 3)
		  (setf (aref y (+ (* 3 (1- k)) r) 0) (elt right-side r))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
                    (v+ (aref net i1 i2)
                        (list (elt solution (+ (* (- j 3) 3) 0))
                              (elt solution (+ (* (- j 3) 3) 1))
                              (elt solution (+ (* (- j 3) 3) 2))))))))))

(defun principal-directions (surface uv)
  "TODO: divides by zero when k2 = 0.
Also, this should be computed with the principal curvatures."
  (let* ((der-00 (bss-evaluate surface uv :derivative '(1 0)))
	 (der-01 (bss-evaluate surface uv :derivative '(0 1)))
	 (der-10 (bss-evaluate surface uv :derivative '(2 0)))
	 (der-11 (bss-evaluate surface uv :derivative '(1 1)))
	 (der-12 (bss-evaluate surface uv :derivative '(0 2)))
	 (normal (vnormalize (cross-product der-00 der-01)))
	 (E (scalar-product der-00 der-00))
	 (F (scalar-product der-00 der-01))
	 (G (scalar-product der-01 der-01))
	 (L (scalar-product normal der-10))
	 (M (scalar-product normal der-11))
	 (N (scalar-product normal der-12))
	 (a (- (* F N) (* G M)))
	 (b (- (* E N) (* G L)))
	 (c (- (* E M) (* F L)))
	 (D (let ((tmp (- (* b b) (* 4 a c))))
	      (if (<= tmp 0) 0 (sqrt tmp))))
	 (l1 (/ (+ (- b) D) (* 2 a)))
	 (l2 (/ (- (- b) D) (* 2 a)))
	 (u-dir (vnormalize der-00))
	 (v-dir (vnormalize der-01)))
    (list (vnormalize (v+ u-dir (v* v-dir l1)))
	  (vnormalize (v+ u-dir (v* v-dir l2))))))

(defun principal-directions (surface uv)
  (let* ((der-00 (bss-evaluate surface uv :derivative '(1 0)))
	 (der-01 (bss-evaluate surface uv :derivative '(0 1)))
	 (der-10 (bss-evaluate surface uv :derivative '(2 0)))
	 (der-11 (bss-evaluate surface uv :derivative '(1 1)))
	 (der-12 (bss-evaluate surface uv :derivative '(0 2)))
	 (normal (vnormalize (cross-product der-00 der-01)))
	 (E (scalar-product der-00 der-00))
	 (F (scalar-product der-00 der-01))
	 (G (scalar-product der-01 der-01))
	 (L (scalar-product normal der-10))
	 (M (scalar-product normal der-11))
	 (N (scalar-product normal der-12))
	 (divisor (/ (- (* E G) (* F F))))
	 (xa (* (- (* M F) (* L G)) divisor))
	 (xb (* (- (* L F) (* M E)) divisor))
	 (xc (* (- (* N F) (* M G)) divisor))
	 (xd (* (- (* M F) (* N E)) divisor))
	 (b (- (+ xa xd)))
	 (c (- (* xa xd) (* xb xc)))
	 (D (let ((tmp (- (* b b) (* 4 c))))
	      (if (<= tmp 0) 0 (sqrt tmp))))
	 (l1 (/ (+ (- b) D) 2))
	 (l2 (/ (- (- b) D) 2))
	 (c1 (/ (- l1 xa) xb))
	 (c2 (/ (- l2 xa) xb))
	 (u-dir (vnormalize der-00))
	 (v-dir (vnormalize der-01)))
    (list (vnormalize (v+ u-dir (v* v-dir c1)))
	  (vnormalize (v+ u-dir (v* v-dir c2))))))

(defun angle-between (v w up-direction)
  "Returns the signed angle between two vectors (according to UP-DIRECTION)."
  (* (acos (scalar-product (vnormalize v) (vnormalize w)))
     (if (< (scalar-product up-direction (cross-product v w)) 0) -1 1)))

(defun normal-curvature (surface uv angle)
  (destructuring-bind (k1 k2)
      (bss-principal-curvatures surface uv)
    (flet ((sqr (x) (* x x)))
      (+ (* k1 (sqr (cos angle))) (* k2 (sqr (sin angle)))))))

(defun ideal-point (curve curvature normal &key endp)
  (let* ((cpts (control-points curve))
	 (n (length cpts))
	 (p0 (elt cpts (if endp (- n 1) 0)))
	 (p1 (elt cpts (if endp (- n 2) 1)))
	 (p2 (elt cpts (if endp (- n 3) 2)))
	 (tangent (vnormalize (v- p1 p0)))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (un (length u))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (if endp (- un p 3) (+ p 2)))
		     (elt u (if endp (- un 3) 2)))
		  (- (elt u (if endp (- un p 2) (+ p 1)))
		     (elt u (if endp (- un 2) 1))))))
	 (q (v+ p1 (v* normal h)))
	 (l (scalar-product (v- p2 q) tangent)))
    (v+ p1 (v* tangent l) (v* normal h))))

;;; ---

;;; Another idea...

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((udegree (ufirst (degrees surface)))
	   (vdegree (usecond (degrees surface)))
	   (uknots (ufirst (knot-vectors surface)))
	   (vknots (usecond (knot-vectors surface)))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (- resolution 2) (* 3 (- m 5)))))
	   (y (make-array (list (- resolution 2) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for d1 = (bss-evaluate surface uv
				    :derivative (if u-dir '(1 0) '(0 1))))
	    (for d1-square = (scalar-product d1 d1))
	    (for k-master = (normal-curvature master uv d1))
	    (for k-surface = (normal-curvature surface uv d1))
	    (for normal = (bss-surface-normal surface uv))
	    (iter (for j from 0 to (- m 6))
		  (iter (for s from 0 below 3)
			(setf (aref x (1- k) (+ (* 3 j) s))
			      (* (bspline-basis vknots (+ j 3) vdegree vk)
				 (elt normal s)))))
	    (setf (aref y (1- k) 0)
		  (/ (* (- k-master k-surface) d1-square
			(- (elt uknots (+ udegree 1)) (elt uknots 2))
			(- (elt uknots (+ udegree 2)) (elt uknots 2)))
		     (* udegree (1- udegree)))))
      (let ((solution (lu-solver:least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
		    (v+ (aref net i1 i2)
			(list (elt solution (+ (* 3 (- j 3)) 0))
			      (elt solution (+ (* 3 (- j 3)) 1))
			      (elt solution (+ (* 3 (- j 3)) 2)))))))))
  surface)

;;; control net normalis iranyu verzio:

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((udegree (ufirst (degrees surface)))
	   (vdegree (usecond (degrees surface)))
	   (uknots (ufirst (knot-vectors surface)))
	   (vknots (usecond (knot-vectors surface)))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (- resolution 2) (- m 5))))
	   (y (make-array (list (- resolution 2) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for d1 = (bss-evaluate surface uv
				    :derivative (if u-dir '(1 0) '(0 1))))
	    (for d1-square = (scalar-product d1 d1))
	    (for k-master = (normal-curvature master uv d1))
	    (for k-surface = (normal-curvature surface uv d1))
	    (for normal = (bss-surface-normal surface uv))
	    (iter (for j from 0 to (- m 6))
		  (setf (aref x (1- k) j)
			(* (bspline-basis vknots (+ j 3) vdegree vk)
			   (scalar-product
			      (if u-dir
				  (control-normal surface index (+ j 3))
				  (control-normal surface (+ j 3) index))
			      normal))))
	    (setf (aref y (1- k) 0)
		  (/ (* (- k-master k-surface) d1-square
			(- (elt uknots (+ udegree 1)) (elt uknots 2))
			(- (elt uknots (+ udegree 2)) (elt uknots 2)))
		     (* udegree (1- udegree)))))
      (let ((solution (lu-solver:least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
	      (for normal = (control-normal surface i1 i2))
              (setf (aref net i1 i2)
		    (v+ (aref net i1 i2)
			(v* normal (elt solution (- j 3)))))))))
  surface)

(defparameter *vb1* (read-rbn "/home/salvi/project/cl-nurbs/models/vb1.rbn"))
(write-rbn (cons (fair-g2-halved *vb1* :halving 'all)
		 (rest *vb1*))
	   "/tmp/g2.rbn")
