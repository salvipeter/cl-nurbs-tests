(in-package :cl-nurbs-tests)

(defparameter *window* '((-1 -1) (1 1)))
(defparameter *curve*
  (make-bspline-curve 3 '(0 0 0 0 0.5 1 1 1 1)
                      '((-0.5 -0.2) (-0.2 0.3) (0.1 0.4) (0.4 0) (0.6 -0.2)))
  "A B-spline curve with the parameter running in [0,1].")
(defparameter *resolution* 41)

(defun closest-point (p)
  (bsc-evaluate *curve* (bsc-project-point *curve* p 10 100)))

(defun closest-point-extended (p)
  (closest-point (v+ p (v* (v- (closest-point p) p) 2))))

(defun grid-point (p)
  "P is an index, e.g. (1 3)."
  (v+ (first *window*)
      (mapcar '* (v* p (/ (1- *resolution*)))
              (v* (apply #'v- *window*) -1))))

(defun closest-grid-point-low (p)
  "Finds the closest grid point indices in the lower left quarter of P."
  (let ((coord (mapcar (lambda (v l) (* v (/ l)))
                       (v- p (first *window*))
                       (v* (apply #'v- *window*) -1))))
    (mapcar #'floor (v* coord (1- *resolution*)))))

(defun closest-grid-point (p)
  (let ((q (closest-grid-point-low p)))
    (iter (for d in '((0 0) (1 0) (0 1) (1 1)))
          (for point = (grid-point (v+ q d)))
          (finding (v+ q d) minimizing (point-distance p point)))))

(let ((w (iter (for i from 0 to 3)
               (collect (/ (iter (for k from 0 to 3)
                                 (when (/= i k)
                                   (multiply (/ (- i k) 3)))))))))
  (defun uniform-cubic-barycentric-lagrange-weights (x)
    (cond ((= x 0) '(1 0 0 0))
          ((= x 1/3) '(0 1 0 0))
          ((= x 2/3) '(0 0 1 0))
          ((= x 1) '(0 0 0 1))
          (t (let* ((weights (iter (for i from 0 to 3)
                                   (for wi in w)
                                   (collect (/ wi (- x (/ i 3))))))
                    (sum (reduce #'+ weights)))
               (mapcar (lambda (w) (/ w sum)) weights))))))

(defun lagrange-curve (points x)
  (let ((weights (uniform-cubic-barycentric-lagrange-weights x))
        (result '(0 0)))
    (iter (for wi in weights)
          (for p in points)
          (setf result (v+ result (v* p wi))))
    result))

(defun lagrange-surface (points p)
  "POINTS is a 3x3 array."
  (let ((wx (uniform-cubic-barycentric-lagrange-weights (first p)))
        (wy (uniform-cubic-barycentric-lagrange-weights (second p)))
        (result '(0 0 0)))
    (iter (for i from 0 to 3)
          (iter (for j from 0 to 3)
                (setf result
                      (v+ result
                          (v* (aref points i j) (elt wx i) (elt wy j))))))
    result))

(defun create-grid (density)
  "DENSITY is the sampling rate of *CURVE* for initial grid points."
  (let ((points ())
        (ghosts ())
        (change t))
    (iter (for i from 0 below density)
          (for x = (/ i (1- density)))
          (pushnew (closest-grid-point (bsc-evaluate *curve* x)) points
                   :test #'equal))
    (iter (while change)
          (setf change nil)
          (iter (for p in points)
                (for cp = (closest-point (grid-point p)))
                (for gp = (closest-grid-point-low cp))
                (iter (for dx from -1 to 2)
                      (iter (for dy from -1 to 2)
                            (for d = (list dx dy))
                            (unless (member (v+ gp d) points :test #'equal)
                              (push (v+ gp d) points)
                              (setf change t))))))
    (iter (for p in points)             ; insert `ghost points'
          (iter (for d in '((-1 0) (0 1) (1 0) (0 -1)))
                (unless (member (v+ p d) points :test #'equal)
                  (pushnew (v+ p d) ghosts :test #'equal))))
    (list points ghosts)))

(defun stencil-parameter (p base)
  (flet ((point (d) (grid-point (v+ base d))))
    (let ((bp (point '(0 0))))
      (list (/ (- (first p) (first bp))
               (- (first (point '(1 0))) (first bp)))
            (/ (- (second p) (second bp))
               (- (second (point '(0 1))) (second bp)))))))

(defun interpolation-matrix (grid)
  (let* ((n (length (first grid)))
         (m (+ n (length (second grid))))
         (result (make-array (list m n) :initial-element 0.0d0)))
    (iter (for p in (append (first grid) (second grid)))
          (for i upfrom 0)
          (for cp = (closest-point (grid-point p)))
          (for base = (closest-grid-point-low cp))
          (for param = (stencil-parameter cp base))
          (for wx = (uniform-cubic-barycentric-lagrange-weights (first param)))
          (for wy = (uniform-cubic-barycentric-lagrange-weights (second param)))
          (iter (for j from -1 to 2)
                (iter (for k from -1 to 2)
                      (for d = (list j k))
                      (for l = (position (v+ base d) (first grid) :test #'equal))
                      (setf (aref result i l)
                            (* (elt wx (1+ j)) (elt wy (1+ k)))))))
    result))

(defun derivation-matrix (grid)
  (let* ((n (length (first grid)))
         (m (+ n (length (second grid))))
         (result (make-array (list n m) :initial-element 0.0d0))
         (ghost-grid (append (first grid) (second grid))))
    (iter (for p in (first grid))
          (for i upfrom 0)
          (iter (for d in '((-1 0) (0 1) (1 0) (0 -1)))
                (for l = (position (v+ p d) ghost-grid :test #'equal))
                (setf (aref result i l) 1.0d0))
          (setf (aref result i i) -4.0d0))
    result))

(defun matrix/diagonal (matrix type)
  "TYPE is :DIAGONAL or :NO-DIAGONAL.
In the :DIAGONAL case, a square matrix is returned."
  (let* ((n (if (eq type :diagonal)
                (let ((n (reduce #'min (array-dimensions matrix))))
                  (list n n))
                (array-dimensions matrix)))
         (result (make-array n)))
    (iter (for i from 0 below (first n))
          (iter (for j from 0 below (second n))
                (setf (aref result i j)
                      (ecase type
                        (:diagonal (if (= i j) (aref matrix i j) 0.0))
                        (:no-diagonal (if (= i j) 0.0 (aref matrix i j)))))))
    result))

(defun laplace-matrix (grid)
  (let ((im (interpolation-matrix grid))
        (dm (derivation-matrix grid)))
    (matrix:m+ (matrix/diagonal dm :diagonal)
               (matrix:multiplication (matrix/diagonal dm :no-diagonal) im))))

(defun matrix-as-sequence (matrix)
  (iter (for i from 0 below (array-dimension matrix 0))
        (collect (iter (for j from 0 below (array-dimension matrix 1))
                       (collect (aref matrix i j))))))

(defun eigenvalues/vectors (matrix)
  (let ((m (grid:make-foreign-array 'double-float :dimensions 2
                                    :initial-contents (matrix-as-sequence matrix))))
    (gsll:eigenvalues-eigenvectors m)))

(defparameter *laplace* (laplace-matrix (create-grid 100)))

(defun show-eigenvector (n)
  (with-open-file (pos "/tmp/positive" :direction :output :if-exists :supersede)
    (with-open-file (neg "/tmp/negative" :direction :output :if-exists :supersede)
      (iter (for i from 0 below 181)
            (if (>= (elt (elt *eigenvectors* n) i) 0)
                (format pos "~{~f~^ ~}~%" (grid-point (elt (first *grid*) i)))
                (format neg "~{~f~^ ~}~%" (grid-point (elt (first *grid*) i))))))))
