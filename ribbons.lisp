(in-package :cl-nurbs-tests)

(defparameter *exponent* 2)
(defparameter *resolution* 60)
(defparameter *tiny* 1.0d-5)

(defun points-from-angles (angles)
  "For example, for a equilateral triangle give '(120 120 120)."
  (iter (for degrees in angles)
	(for angle = (/ (* degrees pi) 180.0d0))
	(for alpha first angle then (+ alpha angle))
	(collect (list (cos alpha) (sin alpha)))))

(defun lines-from-points (points)
  (cons (list (car (last points)) (first points))
	(iter (for k from 0 below (1- (length points)))
	      (collect (list (elt points k) (elt points (1+ k)))))))

(defun point-line-distance (p line &optional signedp)
  (let* ((v (v- (second line) (first line)))
         (d (scalar-product (vnormalize (list (second v) (- (first v))))
                            (v- p (first line)))))
    (if signedp d (abs d))))

(defun line-point (line u)
  (affine-combine (first line) u (second line)))

(defun insidep (lines p)
  (every (lambda (line)
           (> (* (point-line-distance p line t)
                 (point-line-distance '(0 0) line t))
              0))
         lines))

(defun blend (d i)
  (let ((n (length d)))
    (/ (iter (for j from 0 below n)
	     (when (/= i j)
	       (multiply (expt (elt d j) *exponent*))))
       (iter (for k from 0 below n)
	     (sum (iter (for j from 0 below n)
			(when (/= j k)
			  (multiply (expt (elt d j) *exponent*)))))))))

(defun ribbon-blend (lines p i)
  (let ((d (mapcar (lambda (line) (point-line-distance p line)) lines)))
    (cond ((notany (lambda (x) (< (abs x) *tiny*)) d) (blend d i))
	  ((< (min (point-distance (first (elt lines i)) p)
		   (point-distance (second (elt lines i)) p))
	      *tiny*)
	   0.5d0)
	  ((< (point-line-distance p (elt lines i)) *tiny*) 1.0d0)
	  (t 0.0d0))))

(defun corner-blend (lines p i)
  (let ((d (mapcar (lambda (line)
		     (let ((x (point-line-distance p line)))
		       (if (< (abs x) *tiny*) 0 x)))
		   lines))
	(n (length lines)))
    (/ (iter (for j from 0 below n)
	     (when (and (/= i j) (/= (mod (1+ i) n) j))
	       (multiply (expt (elt d j) *exponent*))))
       (iter (for k from 0 below n)
	     (sum (iter (for j from 0 below n)
			(when (and (/= k j) (/= (mod (1+ k) n) j))
			  (multiply (expt (elt d j) *exponent*)))))))))

;;; triangular mesh
(defun triangles (n)
  (iter (with result = '())
	(with inner-start = 0)
	(with outer-vert = 1)
	(for layer from 1 to *resolution*)
	(for inner-vert = inner-start)
	(for outer-start = outer-vert)
	(iter (for side from 0 below n)
	      (iter (with vert = 0)
		    (for next-vert = (if (and (= side (1- n))
					      (= vert (1- layer)))
					 outer-start
					 (1+ outer-vert)))
		    (push (list inner-vert outer-vert next-vert) result)
		    (incf outer-vert)
		    (incf vert)
		    (while (/= vert layer))
		    (for inner-next = (if (and (= side (1- n))
					       (= vert (1- layer)))
					  inner-start
					  (1+ inner-vert)))
		    (push (list inner-vert next-vert inner-next) result)
		    (setf inner-vert inner-next)))
	(setf inner-start outer-start)
	(finally (return (nreverse result)))))

(defun vertices (angles)
  (let* ((points (points-from-angles angles))
	 (lines (lines-from-points points))
	 (n (length lines))
	 (center (v* (reduce #'v+ points) (/ n)))
	 (result (list center)))
    (iter (for j from 1 to *resolution*)
	  (for coeff = (/ j *resolution*))
	  (iter (for k from 0 below n)
		(iter (for i from 0 below j)
		      (for lp = (line-point (elt lines k) (/ i j)))
		      (push (affine-combine center coeff lp) result))))
    (nreverse result)))

(defun write-blends (angles on-off filename &key (blend-function #'ribbon-blend))
  (let* ((n (length angles))
	 (lines (lines-from-points (points-from-angles angles)))
	 (vertices (mapcar (lambda (p)
			     (cons (iter (for i from 0 below n)
					 (when (elt on-off i)
					   (sum (funcall blend-function lines p i))))
				   p))
			   (vertices angles))))
    (write-vtk-indexed-mesh vertices (triangles n) filename)))

;;; quadrilateral mesh
(defun write-blends-quad (angles on-off filename &key (blend-function #'ribbon-blend))
  (let* ((lines (lines-from-points (points-from-angles angles)))
	 (n (length lines))
	 (res (1+ (* 2 *resolution*)))
	 (points (make-array (list res res))))
    (flet ((map-coordinates (x y)
	     (list (/ (- x *resolution*) *resolution*)
		   (/ (- y *resolution*) *resolution*))))
      (iter (for x from 0 below res)
	    (iter (for y from 0 below res)
		  (let ((p (map-coordinates x y)))
		    (setf (aref points x y)
			  (if (insidep lines p)
			      (cons (iter (for i from 0 below n)
					  (when (elt on-off i)
					    (sum (funcall blend-function lines p i))))
				    p)
			      (cons 0 p)))))))
    (write-points2-vtk points filename)))

;; (write-blends '(60 60 80 120 40) '(t t nil nil nil) "/tmp/blend.vtk")
;; (write-blends '(60 60 80 120 40) '(t t t nil nil) "/tmp/corner-blend.vtk" :blend-function #'corner-blend)
