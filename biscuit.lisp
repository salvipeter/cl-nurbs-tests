(in-package :cl-nurbs-tests)

(defun read-lop (filename)
  (flet ((read-array (s &optional d)
           (let ((n (read s)))
             (iter (repeat n)
                   (collect (if d
                                (iter (repeat d) (collect (read s)))
                                (read s)))))))
    (with-open-file (s filename)
      (let ((n (read s)))
        (iter (repeat n)
              (for degree = (read s))
              (for knots = (read-array s))
              (for cpts = (read-array s 3))
              (collect (make-bspline-curve degree knots cpts)))))))

(defvar *biscuit-breadth*)

(defun generate-biscuit (curve prev next filename)
  "Assumes that all curves are parameterized in [0,1]."
  (let* ((prev-d (vnormalize (bsc-evaluate prev 1 :derivative 1)))
         (next-d (vnormalize (bsc-evaluate next 0 :derivative 1)))
         (start-d (vnormalize (bsc-evaluate curve 0 :derivative 1)))
         (end-d (vnormalize (bsc-evaluate curve 1 :derivative 1)))
         (n1 (cross-product prev-d start-d))
         (n2 (cross-product end-d next-d)))
    (flet ((normal (u)
             (v+ (v* n1 (hermite-blend-function 'point 'start u))
                 (v* n2 (hermite-blend-function 'point 'end u))))
           (collect-fan (p n d)
             (iter (for i from 1 below *resolution*)
                   (for phi = (* (/ i *resolution*) pi))
                   (for b = (cross-product d n))
                   (for dir = (v+ (v* b (cos phi)) (v* d (sin phi))))
                   (collect (v+ p (v* dir *biscuit-breadth*))))))
      (let ((side (iter (for i from 0 to *resolution*)
                        (for u = (/ i *resolution*))
                        (for n = (normal u))
                        (for p = (bsc-evaluate curve u))
                        (for d = (vnormalize (bsc-evaluate curve u :derivative 1)))
                        (for dir = (cross-product n d))
                        (collect p)
                        (collect (v+ p (v* dir *biscuit-breadth*)))
                        (collect (v- p (v* dir *biscuit-breadth*)))))
            (start (collect-fan (bsc-evaluate curve 0) n1 (v* start-d -1)))
            (end (collect-fan (bsc-evaluate curve 1) n2 end-d)))
        (with-open-file (s filename :direction :output :if-exists :supersede)
          (dolist (p (append side start end))
            (format s "v~{ ~f~}~%" p))
          (flet ((plus (lst base) (mapcar (lambda (x) (+ x base)) lst))
                 (fan-triangles (base p first last)
                   (format s "f ~d ~d ~d~%" p first (+ 1 base))
                   (iter (for i from 2 below *resolution*)
                         (format s "f ~d ~d ~d~%" p (+ i -1 base) (+ i base)))
                   (format s "f ~d ~d ~d~%" p (+ (1- *resolution*) base) last)))
            (iter (for i from 0 below (* 3 *resolution*) by 3)
                  (format s "f~{ ~d~}~%" (plus '(1 2 4) i))
                  (format s "f~{ ~d~}~%" (plus '(3 1 4) i))
                  (format s "f~{ ~d~}~%" (plus '(4 2 5) i))
                  (format s "f~{ ~d~}~%" (plus '(6 3 4) i)))
            (let ((npoints (* 3 (1+ *resolution*))))
              (fan-triangles npoints 1 2 3)
              (fan-triangles (+ npoints *resolution* -1) (- npoints 2) npoints (1- npoints)))))))))

(defun generate-biscuits-from-lop (filename output-prefix)
  (let ((curves (read-lop filename)))
    (iter (with n = (length curves))
          (for i from 0 below n)
          (for name = (format nil "~a-~a.obj" output-prefix (1+ i)))
          (for im = (mod (1- i) n))
          (for ip = (mod (1+ i) n))
          (generate-biscuit (elt curves i) (elt curves im) (elt curves ip) name))))

#+nil
(let ((*resolution* 50)
      (*biscuit-breadth* 10))
  (generate-biscuits-from-lop
   "/home/salvi/project/shapex/transfinite/models/cagd86.lop"
   "/tmp/cagd86"))
