(in-package :cl-nurbs)

(defparameter *alpha* 0.5)
(defparameter *stability* 1)

(defun 5it-target-curvature (xnode resolution iteration)
  "Returns (((u v) target-mean-curvature)...).
The fixed target values on the sides are taken from the XNODE."
  (let* ((n (if (listp resolution) resolution (list resolution resolution)))
	 (lower (bss-lower-parameter (first xnode)))
	 (upper (bss-upper-parameter (first xnode)))
	 (step (mapcar #'(lambda (x y z) (/ (- x y) (1- z))) upper lower n))
	 (result (make-array n)))
    (flet ((get-surface (i j) ; gives priority to the U surfaces in the corners
	     (cond ((= i 0) (second xnode))
		   ((= i (1- (first n))) (third xnode))
		   ((= j 0) (fourth xnode))
		   ((= j (1- (second n))) (fifth xnode))
		   (t (first xnode)))))
      (dotimes (j (second n))
	(dotimes (i (first n))
	  (let ((u (+ (first lower) (* (first step) i)))
		(v (+ (second lower) (* (second step) j)))
		(surface (get-surface i j)))
	    (setf (aref result i j)
		  (list (list u v)
			(bss-mean-curvature surface (list u v))))))))
    (let ((temp (make-array n)))
      (dotimes (i (first n))
	(setf (aref temp i 0) (second (aref result i 0))
	      (aref temp i (1- (second n))) (second (aref result i (1- (second n))))))
      (dotimes (j (second n))
	(setf (aref temp 0 j) (second (aref result 0 j))
	      (aref temp (1- (first n)) j) (second (aref result (1- (first n)) j))))
      (dotimes (k iteration)
	(iter (for j from 1 below (1- (second n)))
	      (iter (for i from 1 below (1- (first n)))
		    (setf (aref temp i j)
			  (/ (apply #'+ (mapcar (lambda (x y)
						  (second (aref result x y)))
						(list (1- i) i (1+ i) i)
						(list j (1- j) j (1+ j))))
			     4))))
	(iter (for j from 1 below (1- (second n)))
	      (iter (for i from 1 below (1- (first n)))
		    (setf (second (aref result i j)) (aref temp i j))))))
    result))

(defun 5it-tangent-data (xnode)
  "Returns the data as a list of (left-data right-data bottom-data up-data).
Every `data' is a list of (start-point tangent parameter), in a way that
 (v+ start-point (v* tangent parameter)) is the corresponding control point."
  (labels ((get-data (base-cpts cpts)
	     (let* ((start-point (first base-cpts))
		    (tangent (vnormalize
			      (v- start-point (second base-cpts))))
		    (parameter (scalar-product (v- (second cpts) start-point)
					       tangent)))
	       (list start-point tangent parameter)))
	   (get-cpts (surface i u-dir)
	     (let* ((cpts (control-net surface))
		    (n (array-dimension cpts (if u-dir 0 1))))
	       (iter (for j from 0 below n)
		     (collect (aref cpts (if u-dir j i) (if u-dir i j))))))
	   (gen-cp (id i direction flip-base flip)
	     (let ((base-cpts (get-cpts (elt xnode id) i (eq direction 'u)))
		   (cpts (get-cpts (first xnode) i (eq direction 'u))))
	       (get-data (if flip-base (nreverse base-cpts) base-cpts)
			 (if flip (nreverse cpts) cpts)))))
    (let ((n (array-dimensions (control-net (first xnode)))))
      (list (iter (for j from 0 below (second n))
		  (collect (gen-cp 1 j 'u t nil)))
	    (iter (for j from 0 below (second n))
		  (collect (gen-cp 2 j 'u nil t)))
	    (iter (for i from 0 below (first n))
		  (collect (gen-cp 3 i 'v t nil)))
	    (iter (for i from 0 below (first n))
		  (collect (gen-cp 4 i 'v nil t)))))))

(defun 5it-set-inner-corners (cpts tangent-data)
  "Modifies the original control points.
For now, we hope that the original was G1."
  (declare (ignore cpts tangent-data))
  t)

(defun 5it-measure (surface curvatures)
  (let ((nu (array-dimension curvatures 0))
	(nv (array-dimension curvatures 1))
	sides inner)
    (dotimes (j nv)
      (dotimes (i nu)
	(let* ((curvature (aref curvatures i j))
	       (target (second curvature))
	       (mean (bss-mean-curvature surface (first curvature)))
	       (deviation (- target mean))
	       (squared-deviation (* *stability* deviation deviation)))
	  (if (or (= i 0) (= j 0) (= i (1- nu)) (= j (1- nv)))
	      (push squared-deviation sides)
	      (push squared-deviation inner)))))
    (+ (* *alpha* (/ (apply #'+ sides) (length sides)))
       (* (- 1 *alpha*) (/ (apply #'+ inner) (length inner))))))

(defun 5it-measure-thin-plane (surface curvatures)
  (let ((nu (array-dimension curvatures 0))
	(nv (array-dimension curvatures 1))
	sides inner)
    (dotimes (j nv)
      (dotimes (i nu)
	(let* ((curvature (aref curvatures i j))
	       (target (second curvature))
	       (mean (bss-mean-curvature surface (first curvature)))
	       (squared-mean (* *stability* mean mean))
	       (deviation (- target mean))
	       (squared-deviation (* *stability* deviation deviation)))
	  (if (or (= i 0) (= j 0) (= i (1- nu)) (= j (1- nv)))
	      (push squared-deviation sides)
	      (push squared-mean inner)))))
    (+ (* *alpha* (/ (apply #'+ sides) (length sides)))
       (* (- 1 *alpha*) (/ (apply #'+ inner) (length inner))))))

(defun timed-format (stream string &rest rest)
  (let ((now (multiple-value-list (get-decoded-time))))
  (apply #'format
	 stream (concatenate 'string "[~2,'0d:~2,'0d:~2,'0d] " string)
	 (third now) (second now) (first now) rest)))

(defun 5it-fair (xnode &key (resolution 100)
		 (target-iteration 100) (simplex-iteration 5)
		 (fairing-iteration 5))
  (when (every #'< (array-dimensions (control-net (first xnode))) '(5 5))
    (error "Too few control points in the middle patch for fairing"))
  (let* ((curvatures (5it-target-curvature xnode resolution target-iteration))
	 (g1-data (5it-tangent-data xnode))
	 (surface (copy-bspline-surface (first xnode)))
	 (points (control-net surface))
	 (nu (array-dimension points 0))
	 (nv (array-dimension points 1)))
    (5it-set-inner-corners points g1-data)
    (flet ((constrained-minimization (data i direction)
	     (timed-format t "Side minimization: ~d (~a)~%" i direction)
	     (iter (with u-dir = (eq direction 'u))
		   (for j from 2 below (- (if u-dir nv nu) 2))
		   (timed-format t "Side iteration ~d...~%" j)
		   (for u = (if u-dir i j))
		   (for v = (if u-dir j i))
		   (for datum = (elt data j))
		   (for (start tangent parameter) = datum)
		   (for value =
			(car (downhill-simplex:minimize
			      (lambda (x)
				(let ((old (aref points u v)))
				  (setf (aref points u v)
					(v+ start (v* tangent (car x))))
				  (prog1
				      (5it-measure surface curvatures)
				    (setf (aref points u v) old))))
			      (list parameter) (/ simplex-iteration 3))))
		   (setf (third datum) value
			 (aref points u v) (v+ start (v* tangent value))))))
      (dotimes (k fairing-iteration)
	(timed-format t "Starting iteration ~d...~%" k)
	(constrained-minimization (first g1-data) 1 'u)
	(constrained-minimization (second g1-data) (- nu 2) 'u)
	(constrained-minimization (third g1-data) 1 'v)
	(constrained-minimization (fourth g1-data) (- nv 2) 'v)
	(let ((changed nil))
	  (iter (for i from 2 below (- nu 2))
		(iter (for j from 2 below (- nv 2))
		      (for old = (aref points i j))
		      (timed-format t "Inner iteration ~a~%" (list i j))
		      (flet ((fairness-fn (point)
			       (let ((old (aref points i j)))
				 (setf (aref points i j) point)
				 (prog1
				     (5it-measure surface curvatures)
				   (setf (aref points i j) old)))))
			(setf (aref points i j)
			      (downhill-simplex:minimize
			       #'fairness-fn (aref points i j)
			       simplex-iteration))
			(unless (equal old (aref points i j))
			  (setf changed t)))))
	  (unless changed (return-from 5it-fair surface)))))
    surface))

(defun five-surface-iterative-test (xnode filename &rest keys)
  "XNODE should contain (CENTER LEFT RIGHT BOTTOM UP)"
  (let* ((faired (apply #'5it-fair xnode keys))
	 (new-xnode (cons faired (rest xnode))))
    (write-rdn new-xnode filename)
    new-xnode))
