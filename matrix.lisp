;; -*- mode: lisp; syntax: common-lisp -*-

(in-package :cl-nurbs-tests)

(defun matrix-multiplication (m1 m2)
  (let ((n1 (array-dimension m1 0))
	(n (array-dimension m1 1))
	(n2 (array-dimension m2 1)))
    (assert (= n (array-dimension m2 0)) (m1 m2)
	    "The two matrices are incompatible.")
    (let ((result (make-array `(,n1 ,n2))))
      (dotimes (i n1)
	(dotimes (j n2)
	  (setf (aref result i j)
		(iter (for k from 0 below n)
		      (sum (* (aref m1 i k) (aref m2 k j)))))))
      result)))

(defun matrix-inverse-2x2 (m)
  (let* ((a (aref m 0 0))
	 (b (aref m 0 1))
	 (c (aref m 1 0))
	 (d (aref m 1 1))
	 (divisor (- (* a d) (* b c))))
    (make-array '(2 2) :initial-contents
		`((,(/ d divisor) ,(/ (- b) divisor))
		  (,(/ (- c) divisor) ,(/ a divisor))))))

(defun matrix-inverse-3x3 (m)
  (let ((result (make-array '(3 3)))
	(det (+ (* (aref m 0 0) (- (* (aref m 2 2) (aref m 1 1))
				   (* (aref m 2 1) (aref m 1 2))))
		(- (* (aref m 1 0) (- (* (aref m 2 2) (aref m 0 1))
				      (* (aref m 2 1) (aref m 0 2)))))
		(* (aref m 2 0) (- (* (aref m 1 2) (aref m 0 1))
				   (* (aref m 1 1) (aref m 0 2)))))))
    (macrolet ((store (i j neg a1 a2 b1 b2 c1 c2 d1 d2)
		 `(setf (aref result ,i ,j)
			(/ (- (* (aref m ,a1 ,a2) (aref m ,b1 ,b2))
			      (* (aref m ,c1 ,c2) (aref m ,d1 ,d2)))
			   ,(if neg -1 1) det))))
      (store 0 0 nil 2 2 1 1 2 1 1 2)
      (store 0 1  t  2 2 0 1 2 1 0 2)
      (store 0 2 nil 1 2 0 1 1 1 0 2)
      (store 1 0  t  2 2 1 0 2 0 1 2)
      (store 1 1 nil 2 2 0 0 2 0 0 2)
      (store 1 2  t  1 2 0 0 1 0 0 2)
      (store 2 0 nil 2 1 1 0 2 0 1 1)
      (store 2 1  t  2 1 0 0 2 0 0 1)
      (store 2 2 nil 1 1 0 0 1 0 0 1))
    result))
