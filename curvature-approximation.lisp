;; -*- mode: lisp; syntax: common-lisp -*-

(in-package :cl-nurbs-tests)

(defun hessian (deriv-fn fform1-inverse deriv2-coeff)
  (let ((h (make-array '(2 2))))
    (dotimes (k 2)
      (dotimes (j 2)
	(setf (aref h k j)
	      (iter (for l from 0 below 2)
		    (sum (* (aref fform1-inverse k l)
			    (- (funcall deriv-fn j l)
			       (iter (for i from 0 below 2)
				     (sum (* (funcall deriv-fn i)
					     (elt (aref deriv2-coeff j l) i)))))))))))
    h))

(defun fform1-inverse (deriv-fn)
  (let ((fform1 (make-array '(2 2))))
    (dotimes (i 2)
      (dotimes (j 2)
	(setf (aref fform1 i j)
	      (scalar-product (funcall deriv-fn i) (funcall deriv-fn j)))))
    (matrix:inverse-2x2 fform1)))

(defun project-to-plane (point plane)
  "PLANE is represented by a list \(origin normal-vector)."
  (let ((len (scalar-product (v- (first plane) point) (second plane))))
    (v+ point (v* (second plane) len))))

(defun deriv2-coeff (deriv-fn)
  (let ((coeff (make-array '(2 2))))
    (dotimes (i 2)
      (dotimes (j 2)
	(let* ((deriv2 (funcall deriv-fn i j))
	       (du (funcall deriv-fn 0))
	       (dv (funcall deriv-fn 1))
	       (plane (list '(0 0 0) (vnormalize (cross-product du dv))))
	       (projected (project-to-plane deriv2 plane)))
	  (setf (aref coeff i j) (in-system du dv projected)))))
    coeff))

(defun derivative-function (surface uv)
  (lambda (&rest ders)
    (let ((du (count 0 ders))
	  (dv (count 1 ders)))
      (bss-evaluate surface uv :derivative (list du dv)))))

(defun coordinate-function (fn i)
  (lambda (&rest args)
    (elt (apply fn args) i)))

(defun estimated-curvatures (surface reference uv)
  (let* ((deriv-fn (derivative-function reference uv))
	 (fform1-inverse (fform1-inverse deriv-fn))
	 (deriv2-coeff (deriv2-coeff deriv-fn))
	 (deriv-fn (derivative-function surface uv)))
    (flet ((sqr (x) (* x x)))
      (iter (for i from 0 below 3)
	    (for hessian = (hessian (coordinate-function deriv-fn i)
				    fform1-inverse deriv2-coeff))
	    (sum (sqr (matrix:mtrace hessian)) into s1)
	    (sum (matrix:determinant-2x2 hessian) into s2)
	    (sum (matrix:mtrace (matrix:multiplication hessian hessian))
		 into s3)
	    (finally (return (list s1 s2 s3)))))))

(defun precise-curvatures (surface uv)
  (destructuring-bind (k1 k2)
      (bss-principal-curvatures surface uv)
    (list (* (+ k1 k2) (+ k1 k2)) (* k1 k2) (+ (* k1 k1) (* k2 k2)))))

(defparameter *surface* (first (read-rbn "models/top.rbn")))
(let ((uv '(0.3d0 0.1d0)))
  (format t "~a~%~a~%"
	  (precise-curvatures *surface* uv)
	  (estimated-curvatures *surface* *surface* uv)))
