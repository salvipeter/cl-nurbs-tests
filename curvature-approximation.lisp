;; -*- mode: lisp; syntax: common-lisp -*-

(in-package :cl-nurbs-tests)

(defun hessian (deriv-fn fform1-inverse deriv2-coeff)
  (let ((h (make-array '(2 2))))
    (dotimes (k 2)
      (dotimes (j 2)
	(setf (aref h k j)
	      (iter (for l from 0 below 2)
		    (sum (* (aref fform1-inverse k l)
			    (- (funcall deriv-fn j l)
			       (iter (for i from 0 below 2)
				     (sum (* (funcall deriv-fn i)
					     (elt (aref deriv2-coeff j l) i)))))))))))
    h))

(defun fform1-inverse (deriv-fn)
  (let ((fform1 (make-array '(2 2))))
    (dotimes (i 2)
      (dotimes (j 2)
	(setf (aref fform1 i j)
	      (scalar-product (funcall deriv-fn i) (funcall deriv-fn j)))))
    (matrix:inverse-2x2 fform1)))

(defun project-to-plane (point plane)
  "PLANE is represented by a list \(origin normal-vector)."
  (let ((len (scalar-product (v- (first plane) point) (second plane))))
    (v+ point (v* (second plane) len))))

(defun deriv2-coeff (deriv-fn)
  (let ((coeff (make-array '(2 2))))
    (dotimes (i 2)
      (dotimes (j 2)
	(let* ((deriv2 (funcall deriv-fn i j))
	       (du (funcall deriv-fn 0))
	       (dv (funcall deriv-fn 1))
	       (plane (list '(0 0 0) (vnormalize (cross-product du dv))))
	       (projected (project-to-plane deriv2 plane)))
	  (setf (aref coeff i j) (in-system du dv projected)))))
    coeff))

(defun derivative-function (surface uv)
  (lambda (&rest ders)
    (let ((du (count 0 ders))
	  (dv (count 1 ders)))
      (bss-evaluate surface uv :derivative (list du dv)))))

(defun coordinate-function (fn i)
  (lambda (&rest args)
    (elt (apply fn args) i)))

(defun bad-estimated-curvatures (surface uv)
  (let ((duu (bss-evaluate surface uv :derivative '(2 0)))
	(duv (bss-evaluate surface uv :derivative '(1 1)))
	(dvv (bss-evaluate surface uv :derivative '(0 2))))
    (list (vlength2 (v+ duu dvv))
	  (- (scalar-product duu dvv) (vlength2 duv))
	  (+ (vlength2 duu) (* 2 (vlength2 duv)) (vlength2 dvv)))))

(defun estimated-curvatures (surface reference uv)
  (let* ((deriv-fn (derivative-function reference uv))
	 (fform1-inverse (fform1-inverse deriv-fn))
	 (deriv2-coeff (deriv2-coeff deriv-fn))
	 (deriv-fn (derivative-function surface uv)))
    (flet ((sqr (x) (* x x)))
      (iter (for i from 0 below 3)
	    (for hessian = (hessian (coordinate-function deriv-fn i)
				    fform1-inverse deriv2-coeff))
	    (sum (sqr (matrix:mtrace hessian)) into s1)
	    (sum (matrix:determinant-2x2 hessian) into s2)
	    (sum (matrix:mtrace (matrix:multiplication hessian hessian))
		 into s3)
	    (finally (return (list s1 s2 s3)))))))

(defun precise-curvatures (surface uv)
  (destructuring-bind (k1 k2)
      (bss-principal-curvatures surface uv)
    (list (* (+ k1 k2) (+ k1 k2)) (* k1 k2) (+ (* k1 k1) (* k2 k2)))))

(defparameter *surface* (first (read-rbn "models/bottom.rbn")))
(defparameter *faired* (first (read-rbn "models/bottom-faired.rbn")))

#+nil
(let ((uv '(0.3d0 0.1d0)))
  (format t "~a~%~a~%"
	  (precise-curvatures *surface* uv)
	  (estimated-curvatures *surface* *surface* uv)
	  (bad-estimated-curvatures *surface* *surface* uv)))

(defun write-curvatures (surface reference filename resolution)
  (unless (listp resolution)
    (setf resolution (list resolution resolution)))
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "# vtk DataFile Version 1.0~
               ~%B-Spline Surface~
               ~%ASCII~
               ~%DATASET POLYDATA~%~
               ~%POINTS ~d float~%" (* (first resolution) (second resolution)))
    (let* ((lower (mapcar #'max (bss-lower-parameter surface)
			  (bss-lower-parameter reference)))
	   (upper (mapcar #'min (bss-upper-parameter surface)
			  (bss-upper-parameter reference)))
	   (u-res (first resolution))
	   (v-res (second resolution))
	   (curvatures nil))
      (dotimes (j v-res)
	(dotimes (i u-res)
	  (let* ((uv (list (interpolate (first lower)
					(/ i (1- u-res))
					(first upper))
			   (interpolate (second lower)
					(/ j (1- v-res))
					(second upper))))
		 (p (bss-evaluate surface uv)))
	    (format s "~{~f ~}~%" p)
	    (push (append (precise-curvatures surface uv)
			  (estimated-curvatures surface reference uv)
			  (bad-estimated-curvatures surface uv))
		  curvatures))))
      (setf curvatures (nreverse curvatures))
      (format s "~%POLYGONS ~d ~d~%"
	      (* (1- u-res) (1- v-res)) (* (1- u-res) (1- v-res) 5))
      (dotimes (j (1- v-res))
	(dotimes (i (1- u-res))
	  (format s "4 ~d ~d ~d ~d~%"
		  (+ (* j u-res) i) (+ (* j u-res) i 1)
		  (+ (* j u-res) i u-res 1) (+ (* j u-res) i u-res))))
      (format s "~%POINT_DATA ~d~%" (* (first resolution) (second resolution)))
      (flet ((write-scalars (index name)
	       (format s "~%SCALARS ~a float 1~
                          ~%LOOKUP_TABLE default~%"
		       name)
	       (loop for c in curvatures do
		     (format s "~f~%" (elt c index)))))
	(write-scalars 0 "(k1+k2)^2_precise")
	(write-scalars 1 "k1*k2_precise")
	(write-scalars 2 "k1^2+k2^2_precise")
	(write-scalars 3 "(k1+k2)^2_estimation")
	(write-scalars 4 "k1*k2_estimation")
	(write-scalars 5 "k1^2+k2^2_estimation")
	(write-scalars 6 "(k1+k2)^2_simple_estimation")
	(write-scalars 7 "k1*k2_simple_estimation")
	(write-scalars 8 "k1^2+k2^2_simple_estimation")))))

;; (write-curvatures *faired* *surface* "/tmp/faired.vtk" 100)
;;; scalar ranges: 0 - 3e-4; 0 - 5e-5; 0 - 1e-4

(defun target-hessian (surface resolution &optional (iterations 100))
  (let ((result (make-array resolution))
	(temp (make-array resolution)))
    (iter (with (low-u low-v) = (bss-lower-parameter surface))
	  (with (high-u high-v) = (bss-upper-parameter surface))
	  (for i from 0 below (first resolution))
	  (for u = (interpolate low-u (/ i (1- (first resolution))) high-u))
	  (iter (for j from 0 below (second resolution))
		(for v = (interpolate low-v (/ j (1- (second resolution)))
				      high-v))
		(for deriv-fn = (derivative-function surface (list u v)))
		(for fform1-inverse = (fform1-inverse deriv-fn))
		(for deriv2-coeff = (deriv2-coeff deriv-fn))
		(for hessians =
		     (mapcar (lambda (i)
			       (hessian (coordinate-function deriv-fn i)
					fform1-inverse deriv2-coeff))
			     '(0 1 2)))
		(setf (aref result i j)
		      (mapcan (lambda (hessian)
				(list (aref hessian 0 0) (aref hessian 0 1)
				      (aref hessian 1 0) (aref hessian 1 1)))
			      hessians))))
    (iter (repeat iterations)
	  (iter (for i from 1 below (1- (first resolution)))
		(iter (for j from 1 below (1- (second resolution)))
		      (for left = (aref result (1- i) j))
		      (for right = (aref result (1+ i) j))
		      (for top = (aref result i (1- j)))
		      (for bottom = (aref result i (1+ j)))
		      (setf (aref temp i j)
			    (v* (v+ left right top bottom) 1/4))))
	  (iter (for i from 1 below (1- (first resolution)))
		(iter (for j from 1 below (1- (second resolution)))
		      (setf (aref result i j) (aref temp i j)))))
    result))

;;; (defparameter *dummy* (target-hessian *surface* '(20 20) 0))
;;; (defparameter *target* (target-hessian *surface* '(20 20)))

(defun basis-functions (surface uv)
  (destructuring-bind (u-knots v-knots) (knot-vectors surface)
    (destructuring-bind (u-deg v-deg) (degrees surface)
      (let ((u (first uv))
	    (v (second uv)))
	(list (lambda (i du)
		(bspline-basis u-knots i u-deg u :derivative du))
	      (lambda (j dv)
		(bspline-basis v-knots j v-deg v :derivative dv)))))))

(defun fair-by-hessian (surface resolution target)
  (let* ((net (control-net surface))
	 (n (1- (array-dimension net 0)))
	 (m (1- (array-dimension net 1)))
	 (u-low (first (bss-lower-parameter surface)))
	 (u-high (first (bss-upper-parameter surface)))
	 (v-low (second (bss-lower-parameter surface)))
	 (v-high (second (bss-upper-parameter surface)))
	 (length-u (- u-high u-low))
	 (length-v (- v-high v-low))
	 (ures (first resolution))
	 (vres (second resolution))
	 (x (make-array (list (* 12 (- ures 2) (- vres 2))
			      (* 3 (1- n) (1- m)))
			:initial-element 0.0d0))
	 (y (make-array (list (* 12 (- ures 2) (- vres 2)) 1))))
    (iter (with h1 = (make-array 2))
	  (with h2 = (make-array '(2 2)))
	  (for ui from 1 below (1- ures))
	  (for u = (+ u-low (/ (* ui length-u) (1- ures))))
	  (iter (for vi from 1 below (1- vres))
		(for v = (+ v-low (/ (* vi length-v) (1- vres))))
		(for uv = (list u v))
		(for deriv-fn = (derivative-function surface uv))
		(for g = (fform1-inverse deriv-fn))
		(for gamma = (deriv2-coeff deriv-fn))
		(for (u-basis v-basis) = (basis-functions surface uv))
		(for row-base = (* 12 (+ (* (1- vi) (- ures 2)) (1- ui))))
		(for tvalues = (aref target ui vi))
		(iter (for k from 0 below 2)
		      (iter (for l from 0 below 2)
			    (for row = (+ row-base (* 3 (+ (* k 2) l))))
			    (iter (for c from 0 below 3)
				  (incf (aref y (+ row c) 0)
					(elt tvalues (+ (* c 4) (* 2 k) l))))))
		(flet ((gamma (a b c) (elt (aref gamma a b) c)))
		  (iter (for i from 0 to n)
			(for bu-0 = (funcall u-basis i 0))
			(for bu-1 = (funcall u-basis i 1))
			(for bu-2 = (funcall u-basis i 2))
			(iter (for j from 0 to m)
			      (for bv-0 = (funcall v-basis j 0))
			      (for bv-1 = (funcall v-basis j 1))
			      (for bv-2 = (funcall v-basis j 2))
			      (setf (elt h1 0) (* bu-1 bv-0))
			      (setf (elt h1 1) (* bu-0 bv-1))
			      (setf (aref h2 0 0) (* bu-2 bv-0))
			      (setf (aref h2 0 1) (* bu-1 bv-1))
			      (setf (aref h2 1 0) (* bu-1 bv-1))
			      (setf (aref h2 1 1) (* bu-0 bv-2))
			      (for column = (* 3 (+ (* (1- i) (- m 2)) (1- j))))
			      (flet ((hessian-base (k l)
				       (- (+ (* (aref g k 0) (aref h2 l 0)) (* (aref g k 1) (aref h2 l 1)))
					  (* (+ (* (aref g k 0) (gamma l 0 0)) (* (aref g k 1) (gamma l 1 0)))
					     (elt h1 0))
					  (* (+ (* (aref g k 0) (gamma l 0 1)) (* (aref g k 1) (gamma l 1 1)))
					     (elt h1 1)))))
				(iter (for k from 0 below 2)
				      (iter (for l from 0 below 2)
					    (for h = (hessian-base k l))
					    (for row = (+ row-base (* 3 (+ (* k 2) l))))
					    (iter (for c from 0 below 3)
						  (if (or (= i 0) (= i n) (= j 0) (= j m))
						      (decf (aref y (+ row c) 0) h)
						    (incf (aref x (+ row c) (+ column c)) h)))))))))))
    (describe x)
    (describe y)
    (let ((solution (lu-solver:least-squares x y))
	  (result (copy-bspline-surface surface)))
      (iter (with net = (control-net result))
	    (for i from 0 below (1- n))
	    (iter (for j from 0 below (1- m))
		  (setf (aref net (1+ i) (1+ j))
			(list (elt solution (+ (* 3 (+ (* i (- m 2)) j)) 0))
			      (elt solution (+ (* 3 (+ (* i (- m 2)) j)) 1))
			      (elt solution (+ (* 3 (+ (* i (- m 2)) j)) 2))))))
      result)))
