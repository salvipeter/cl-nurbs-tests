;; -*- mode: lisp; syntax: common-lisp -*-

(in-package :cl-nurbs-tests)

(defun hessian (deriv-fn fform1-inverse deriv2-coeff)
  (let ((h (make-array '(2 2))))
    (dotimes (k 2)
      (dotimes (j 2)
	(setf (aref h k j)
	      (iter (for l from 0 below 2)
		    (sum (* (aref fform1-inverse k l)
			    (- (funcall deriv-fn j l)
			       (iter (for i from 0 below 2)
				     (sum (* (funcall deriv-fn i)
					     (elt (aref deriv2-coeff j l) i)))))))))))
    h))

(defun fform1-inverse (deriv-fn)
  (let ((fform1 (make-array '(2 2))))
    (dotimes (i 2)
      (dotimes (j 2)
	(setf (aref fform1 i j)
	      (scalar-product (funcall deriv-fn i) (funcall deriv-fn j)))))
    (matrix:inverse-2x2 fform1)))

(defun project-to-plane (point plane)
  "PLANE is represented by a list \(origin normal-vector)."
  (let ((len (scalar-product (v- (first plane) point) (second plane))))
    (v+ point (v* (second plane) len))))

(defun deriv2-coeff (deriv-fn)
  (let ((coeff (make-array '(2 2))))
    (dotimes (i 2)
      (dotimes (j 2)
	(let* ((deriv2 (funcall deriv-fn i j))
	       (du (funcall deriv-fn 0))
	       (dv (funcall deriv-fn 1))
	       (plane (list '(0 0 0) (vnormalize (cross-product du dv))))
	       (projected (project-to-plane deriv2 plane)))
	  (setf (aref coeff i j) (in-system du dv projected)))))
    coeff))

(defun derivative-function (surface uv)
  (lambda (&rest ders)
    (let ((du (count 0 ders))
	  (dv (count 1 ders)))
      (bss-evaluate surface uv :derivative (list du dv)))))

(defun coordinate-function (fn i)
  (lambda (&rest args)
    (elt (apply fn args) i)))

(defun bad-estimated-curvatures (surface uv)
  (let ((duu (bss-evaluate surface uv :derivative '(2 0)))
	(duv (bss-evaluate surface uv :derivative '(1 1)))
	(dvv (bss-evaluate surface uv :derivative '(0 2))))
    (list (vlength2 (v+ duu dvv))
	  (- (scalar-product duu dvv) (vlength2 duv))
	  (+ (vlength2 duu) (* 2 (vlength2 duv)) (vlength2 dvv)))))

(defun estimated-curvatures (surface reference uv)
  (let* ((deriv-fn (derivative-function reference uv))
	 (fform1-inverse (fform1-inverse deriv-fn))
	 (deriv2-coeff (deriv2-coeff deriv-fn))
	 (deriv-fn (derivative-function surface uv)))
    (flet ((sqr (x) (* x x)))
      (iter (for i from 0 below 3)
	    (for hessian = (hessian (coordinate-function deriv-fn i)
				    fform1-inverse deriv2-coeff))
	    (sum (sqr (matrix:mtrace hessian)) into s1)
	    (sum (matrix:determinant-2x2 hessian) into s2)
	    (sum (matrix:mtrace (matrix:multiplication hessian hessian))
		 into s3)
	    (finally (return (list s1 s2 s3)))))))

(defun precise-curvatures (surface uv)
  (destructuring-bind (k1 k2)
      (bss-principal-curvatures surface uv)
    (list (* (+ k1 k2) (+ k1 k2)) (* k1 k2) (+ (* k1 k1) (* k2 k2)))))

(defparameter *surface* (first (read-rbn "models/bottom.rbn")))
(defparameter *faired* (first (read-rbn "models/bottom-faired.rbn")))

#+nil
(let ((uv '(0.3d0 0.1d0)))
  (format t "~a~%~a~%"
	  (precise-curvatures *surface* uv)
	  (estimated-curvatures *surface* *surface* uv)
	  (bad-estimated-curvatures *surface* *surface* uv)))

(defun write-curvatures (surface reference filename resolution)
  (unless (listp resolution)
    (setf resolution (list resolution resolution)))
  (with-open-file (s filename :direction :output :if-exists :supersede)
    (format s "# vtk DataFile Version 1.0~
               ~%B-Spline Surface~
               ~%ASCII~
               ~%DATASET POLYDATA~%~
               ~%POINTS ~d float~%" (* (first resolution) (second resolution)))
    (let* ((lower (mapcar #'max (bss-lower-parameter surface)
			  (bss-lower-parameter reference)))
	   (upper (mapcar #'min (bss-upper-parameter surface)
			  (bss-upper-parameter reference)))
	   (u-res (first resolution))
	   (v-res (second resolution))
	   (curvatures nil))
      (dotimes (j v-res)
	(dotimes (i u-res)
	  (let* ((uv (list (interpolate (first lower)
					(/ i (1- u-res))
					(first upper))
			   (interpolate (second lower)
					(/ j (1- v-res))
					(second upper))))
		 (p (bss-evaluate surface uv)))
	    (format s "~{~f ~}~%" p)
	    (push (append (precise-curvatures surface uv)
			  (estimated-curvatures surface reference uv)
			  (bad-estimated-curvatures surface uv))
		  curvatures))))
      (setf curvatures (nreverse curvatures))
      (format s "~%POLYGONS ~d ~d~%"
	      (* (1- u-res) (1- v-res)) (* (1- u-res) (1- v-res) 5))
      (dotimes (j (1- v-res))
	(dotimes (i (1- u-res))
	  (format s "4 ~d ~d ~d ~d~%"
		  (+ (* j u-res) i) (+ (* j u-res) i 1)
		  (+ (* j u-res) i u-res 1) (+ (* j u-res) i u-res))))
      (format s "~%POINT_DATA ~d~%" (* (first resolution) (second resolution)))
      (flet ((write-scalars (index name)
	       (format s "~%SCALARS ~a float 1~
                          ~%LOOKUP_TABLE default~%"
		       name)
	       (loop for c in curvatures do
		     (format s "~f~%" (elt c index)))))
	(write-scalars 0 "(k1+k2)^2_precise")
	(write-scalars 1 "k1*k2_precise")
	(write-scalars 2 "k1^2+k2^2_precise")
	(write-scalars 3 "(k1+k2)^2_estimation")
	(write-scalars 4 "k1*k2_estimation")
	(write-scalars 5 "k1^2+k2^2_estimation")
	(write-scalars 6 "(k1+k2)^2_simple_estimation")
	(write-scalars 7 "k1*k2_simple_estimation")
	(write-scalars 8 "k1^2+k2^2_simple_estimation")))))

;; (write-curvatures *faired* *surface* "/tmp/faired.vtk" 100)
;;; scalar ranges: 0 - 3e-4; 0 - 5e-5; 0 - 1e-4
