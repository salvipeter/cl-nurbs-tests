;; -*- mode: lisp; syntax: common-lisp -*-

(in-package :cl-nurbs-tests)

(defun halve-end-intervals (surface)
  (flet ((one-side (surface u-dir endp)
	   (flet ((ufirst (lst) (if u-dir (first lst) (second lst))))
	     (let* ((degree (ufirst (degrees surface)))
		    (knots (ufirst (knot-vectors surface)))
		    (u1 (if endp
			    (elt knots (- (length knots) degree 2))
			    (elt knots degree)))
		    (u2 (if endp
			    (elt knots (- (length knots) degree 1))
			    (elt knots (1+ degree))))
		    (u (interpolate u1 0.5 u2)))
	       (bss-insert-knot surface u :u-direction u-dir)))))
    (one-side (one-side (one-side (one-side surface t t) t nil) nil t) nil nil)))

(defun halve-all-intervals (surface)
  (flet ((one-side (surface u-dir)
	   (flet ((ufirst (lst) (if u-dir (first lst) (second lst))))
	     (iter (with result = surface)
		   (with knots = (ufirst (knot-vectors surface)))
		   (for k from 1 below (length knots))
		   (unless (= (elt knots (1- k)) (elt knots k))
		     (let ((u (/ (+ (elt knots (1- k)) (elt knots k)) 2)))
		       (setf result
			     (bss-insert-knot result u :u-direction u-dir))))
		   (finally (return result))))))
    (one-side (one-side surface t) nil)))

(defun halve-inner-intervals (surface)
  (flet ((one-side (surface u-dir)
	   (flet ((ufirst (lst) (if u-dir (first lst) (second lst))))
	     (iter (with result = surface)
		   (with degree = (ufirst (degrees surface)))
		   (with knots = (ufirst (knot-vectors surface)))
		   (for k from (+ degree 2)
			below (- (length knots) degree 1))
		   (unless (= (elt knots (1- k)) (elt knots k))
		     (let ((u (/ (+ (elt knots (1- k)) (elt knots k)) 2)))
		       (setf result
			     (bss-insert-knot result u :u-direction u-dir))))
		   (finally (return result))))))
    (one-side (one-side surface t) nil)))

(defun normal-curvature (surface uv direction)
  (let* ((der-00 (bss-evaluate surface uv :derivative '(1 0)))
	 (der-01 (bss-evaluate surface uv :derivative '(0 1)))
	 (der-10 (bss-evaluate surface uv :derivative '(2 0)))
	 (der-11 (bss-evaluate surface uv :derivative '(1 1)))
	 (der-12 (bss-evaluate surface uv :derivative '(0 2)))
	 (normal (vnormalize (cross-product der-00 der-01)))
	 (E (scalar-product der-00 der-00))
	 (F (scalar-product der-00 der-01))
	 (G (scalar-product der-01 der-01))
	 (L (scalar-product normal der-10))
	 (M (scalar-product normal der-11))
	 (N (scalar-product normal der-12))
	 (x (/ (scalar-product direction der-01)
	       (scalar-product direction der-00))))
    (/ (+ L (* 2 M x) (* N x x))
       (+ E (* 2 F x) (* G x x)))))

(defun ideal-point (curve curvature normal &key endp)
  (let* ((curve (if endp (bsc-reverse-parameterization curve) curve))
	 (cpts (control-points curve))
	 (p0 (elt cpts 0))
	 (p1 (elt cpts 1))
	 (p2 (elt cpts 2))
	 (tangent (vnormalize (v- p1 p0)))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (+ p 2)) (elt u 2))
		  (- (elt u (+ p 1)) (elt u 1)))))
	 (q (v+ p1 (v* normal h)))
	 (l (scalar-product (v- p2 q) tangent)))
    (v+ p1 (v* tangent l) (v* normal h))))

(defun ensure-g2-one-side (surface master resolution &key u-dir endp)
  "Ensure destructively G2-connectivity with MASTER at one side of SURFACE.

RESOLUTION gives the size of the LSQ-matrix used in the minimization.
The twist control points will not be moved."
  (flet ((ufirst (lst) (if u-dir (first lst) (second lst)))
	 (usecond (lst) (if u-dir (second lst) (first lst))))
    (let* ((p (degrees surface))
	   (knots (knot-vectors surface))
	   (net (control-net surface))
	   (n (1- (array-dimension net (if u-dir 0 1))))
	   (m (1- (array-dimension net (if u-dir 1 0))))
	   (u-low (ufirst (bss-lower-parameter surface)))
	   (u-high (ufirst (bss-upper-parameter surface)))
	   (v-low (usecond (bss-lower-parameter surface)))
	   (v-high (usecond (bss-upper-parameter surface)))
	   (u (if endp u-high u-low))
	   (length-v (- v-high v-low))
	   (index (if endp (- n 2) 2))
	   (x (make-array (list (* (- resolution 2) 3) (* (- m 5) 3))))
	   (y (make-array (list (* (- resolution 2) 3) 1))))
      (iter (for k from 1 below (1- resolution))
	    (for vk = (+ v-low (/ (* k length-v) (1- resolution))))
	    (for uv = (if u-dir (list u vk) (list vk u)))
	    (for bsc = (bss-get-surface-curve surface vk :u-curve u-dir))
	    (for bscn = (length (control-points bsc)))
	    (for bsc-dir =
		 (v- (elt (control-points bsc) (if endp (- bscn 2) 1))
		     (elt (control-points bsc) (if endp (- bscn 1) 0))))
	    (for ideal = (ideal-point bsc (normal-curvature master uv bsc-dir)
				      (bss-surface-normal surface uv)
				      :endp endp))
	    (for c = (iter (for j from 3 to (- m 3))
			   (collect (bspline-basis (usecond knots) j
						   (usecond p) vk))))
	    (iter (for j from 0 to (- m 6))
		  (iter (for r from 0 below 3)
			(iter (for s from 0 below 3)
			      (setf (aref x (+ (* 3 (1- k)) r) (+ (* 3 j) s))
				    (if (= r s) (elt c j) 0)))))
	    (for right-side =
		 (v- ideal (elt (control-points bsc) (if endp (- bscn 3) 2))))
	    (iter (for r from 0 below 3)
		  (setf (aref y (+ (* 3 (1- k)) r) 0) (elt right-side r))))
      (let ((solution (least-squares x y)))
        (iter (for j from 3 to (- m 3))
              (for i1 = (if u-dir index j))
              (for i2 = (if u-dir j index))
              (setf (aref net i1 i2)
                    (v+ (aref net i1 i2)
                        (list (elt solution (+ (* (- j 3) 3) 0))
                              (elt solution (+ (* (- j 3) 3) 1))
                              (elt solution (+ (* (- j 3) 3) 2))))))))))

(defun ensure-g2-continuity (surface lsurface rsurface dsurface usurface res)
  (let ((result (copy-bspline-surface surface)))
    (ensure-g2-one-side result lsurface (second res) :u-dir t :endp nil)
    (ensure-g2-one-side result rsurface (second res) :u-dir t :endp t)
    (ensure-g2-one-side result dsurface (first res) :u-dir nil :endp nil)
    (ensure-g2-one-side result usurface (first res) :u-dir nil :endp t)
    result))

;;; Pl:
#+nil
(apply #'ensure-g2-continuity (halve-end-intervals (first *xnode*))
       (append (rest *xnode*) '((100 100))))

(in-package :cl-nurbs)

;;; otlet:
;;; minden kontrollponthoz generaljunk parameterertekeket, amik lefedik azt
;;; az intervallumot, ahol a kontrollpontnak hatasa van, es a fairness
;;; fuggveny csak ezeknek a valtozasat nezze.

#+nil
(defun bss-fair (surface &key (measure #'fairness) (resolution 100)
		 (target-iteration 100) (simplex-iteration 5)
		 (fairing-iteration 5) (lock-endpoints t))
  (let* ((parameters (arc-length-sampling curve from to resolution))
	 (curvatures (target-curvature curve parameters target-iteration))
	 (new-surface (copy-bspline-surface surface))
	 (net (control-net new-surface))
	 (size (array-dimensions net)))
    (dotimes (k fairing-iteration)
      (let ((low (if lock-endpoints 1 0))
	    (high-u (if lock-endpoints (1- (first size)) (first size)))
	    (high-v (if lock-endpoints (1- (second size)) (second size))))
	(iter (for i from low below high-u)
	      (iter (for j from low below high-v)
		    (flet ((fairness-fn (point)
			     (let ((old (elt points i j)))
			       (setf (elt points i j) point)
			       (prog1 (funcall measure new-surface
					       parameters curvatures)
				 (setf (elt points i j) old)))))
		      (setf (elt points i j)
			    (downhill-simplex:minimize
			     #'fairness-fn (elt points i j)
			     simplex-iteration)))))))
    new-surface))

#+nil
(defun principal-directions (surface uv)
  "TODO: divides by zero when k2 = 0.
Also, this should be computed with the principal curvatures."
  (let* ((der-00 (bss-evaluate surface uv :derivative '(1 0)))
	 (der-01 (bss-evaluate surface uv :derivative '(0 1)))
	 (der-10 (bss-evaluate surface uv :derivative '(2 0)))
	 (der-11 (bss-evaluate surface uv :derivative '(1 1)))
	 (der-12 (bss-evaluate surface uv :derivative '(0 2)))
	 (normal (vnormalize (cross-product der-00 der-01)))
	 (E (scalar-product der-00 der-00))
	 (F (scalar-product der-00 der-01))
	 (G (scalar-product der-01 der-01))
	 (L (scalar-product normal der-10))
	 (M (scalar-product normal der-11))
	 (N (scalar-product normal der-12))
	 (a (- (* F N) (* G M)))
	 (b (- (* E N) (* G L)))
	 (c (- (* E M) (* F L)))
	 (D (let ((tmp (- (* b b) (* 4 a c))))
	      (if (<= tmp 0) 0 (sqrt tmp))))
	 (l1 (/ (+ (- b) D) (* 2 a)))
	 (l2 (/ (- (- b) D) (* 2 a)))
	 (u-dir (vnormalize der-00))
	 (v-dir (vnormalize der-01)))
    (list (vnormalize (v+ u-dir (v* v-dir l1)))
	  (vnormalize (v+ u-dir (v* v-dir l2))))))

#+nil
(defun principal-directions (surface uv)
  (let* ((der-00 (bss-evaluate surface uv :derivative '(1 0)))
	 (der-01 (bss-evaluate surface uv :derivative '(0 1)))
	 (der-10 (bss-evaluate surface uv :derivative '(2 0)))
	 (der-11 (bss-evaluate surface uv :derivative '(1 1)))
	 (der-12 (bss-evaluate surface uv :derivative '(0 2)))
	 (normal (vnormalize (cross-product der-00 der-01)))
	 (E (scalar-product der-00 der-00))
	 (F (scalar-product der-00 der-01))
	 (G (scalar-product der-01 der-01))
	 (L (scalar-product normal der-10))
	 (M (scalar-product normal der-11))
	 (N (scalar-product normal der-12))
	 (divisor (/ (- (* E G) (* F F))))
	 (xa (* (- (* M F) (* L G)) divisor))
	 (xb (* (- (* L F) (* M E)) divisor))
	 (xc (* (- (* N F) (* M G)) divisor))
	 (xd (* (- (* M F) (* N E)) divisor))
	 (b (- (+ xa xd)))
	 (c (- (* xa xd) (* xb xc)))
	 (D (let ((tmp (- (* b b) (* 4 c))))
	      (if (<= tmp 0) 0 (sqrt tmp))))
	 (l1 (/ (+ (- b) D) 2))
	 (l2 (/ (- (- b) D) 2))
	 (c1 (/ (- l1 xa) xb))
	 (c2 (/ (- l2 xa) xb))
	 (u-dir (vnormalize der-00))
	 (v-dir (vnormalize der-01)))
    (list (vnormalize (v+ u-dir (v* v-dir c1)))
	  (vnormalize (v+ u-dir (v* v-dir c2))))))

#+nil
(defun angle-between (v w up-direction)
  "Returns the signed angle between two vectors (according to UP-DIRECTION)."
  (* (acos (scalar-product (vnormalize v) (vnormalize w)))
     (if (< (scalar-product up-direction (cross-product v w)) 0) -1 1)))

#+nil
(defun normal-curvature (surface uv angle)
  (destructuring-bind (k1 k2)
      (bss-principal-curvatures surface uv)
    (flet ((sqr (x) (* x x)))
      (+ (* k1 (sqr (cos angle))) (* k2 (sqr (sin angle)))))))

#+nil
(defun ideal-point (curve curvature normal &key endp)
  (let* ((cpts (control-points curve))
	 (n (length cpts))
	 (p0 (elt cpts (if endp (- n 1) 0)))
	 (p1 (elt cpts (if endp (- n 2) 1)))
	 (p2 (elt cpts (if endp (- n 3) 2)))
	 (tangent (vnormalize (v- p1 p0)))
	 (d (vlength (v- p1 p0)))
	 (p (degree curve))
	 (u (knot-vector curve))
	 (un (length u))
	 (h (* curvature (* d d) (/ p (1- p))
	       (/ (- (elt u (if endp (- un p 3) (+ p 2)))
		     (elt u (if endp (- un 3) 2)))
		  (- (elt u (if endp (- un p 2) (+ p 1)))
		     (elt u (if endp (- un 2) 1))))))
	 (q (v+ p1 (v* normal h)))
	 (l (scalar-product (v- p2 q) tangent)))
    (v+ p1 (v* tangent l) (v* normal h))))